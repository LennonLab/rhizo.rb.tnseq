---
title: "alphadiv_RAC_multivariate"
author: "Caleb Hill, John McMullen"
date: "2024-02-12"
output: html_document
---

##Libraries required for analyses
```{r}
library(vegan) #multivariate analyses
library(stringr) #Data wrangling
library(tidyverse) #Data wrangling
library(ggdendro) #Tree drawing for cluster dendrogram
library(fgsea) #gene enrichment
library(coin)
library(purrr)
library(car) #ANOVAs
require("psych") #model assessment for PCAs
library(zCompositions)
```


##Data
```{r Chunk 1: Data wrangling}

#FITNESS SCORE data--log2 ratios of endpoint/starting counts
fitdat = read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/fit_logratios.tab", row.names = 1)
goodfitdat <- fitdat
#remove outlier #39
goodfitdat <- goodfitdat[, -c(17)]


#COUNTS DATA for analyses that can't use log ratio data for whatever reason (negative numbers in data, etc)
cleanrbdat = t(read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/gene_counts_clean.tab", row.names = 1))
goodcountdat <- cleanrbdat
#remove outlier #39
goodcountdat <- goodcountdat[-c(15), ]



#METADATA that includes subpopulation and nitrogen treatment
metadat = read.csv(file = "~/GitHub/rhizo.rb.tnseq/Data/smeliplant_metadata_plant_seq.csv")
#remove rows for sample id 25, 34, 36, and 38--reads were < 500,000; also remove outlier #39
metadat = metadat %>% filter(Barseq_Index != "IT025" & Barseq_Index != "IT034" & Barseq_Index != "IT036" & Barseq_Index != "IT038" & Barseq_Index != "IT039")
metadat$Nitrogen_addition <- as.factor(metadat$Nitrogen_addition)
```


##Setup dataframes for downstream analyses
###Count data
```{r}
#remove description from column names, leaving only locus id
newcountnames <- substr(colnames(goodcountdat), 0, 9)
colnames(goodcountdat) <- trimws(newcountnames) 
goodcountdat <- as.data.frame(goodcountdat)

#trim extra chars off SMa names
original_colnames <- colnames(goodcountdat)
new_colnames <- ifelse(
  startsWith(original_colnames, "SMa"),
  substr(original_colnames, 1, nchar(original_colnames) - 2),
  original_colnames
)

# --- 4. Assign the new names back to the dataframe ---
colnames(goodcountdat) <- new_colnames


#clean up and labels data by treatment/compartment from the meta; remove the t0
goodcountdat = goodcountdat %>% 
  mutate(Subpop = metadat$Subpop) %>% 
  mutate(Nitrogen = metadat$Nitrogen_addition) %>% 
  mutate(plant_ID = metadat$plantID) %>%
  filter(Subpop != "t0")
```


##Diversity analyses
###Setup dataframe for indices
```{r Chunk 2: Alpha diversity}
#SHANNON DIVERSITY to compare richness and evenness among samples
#Continuous measure
diversity.fit <- diversity(goodcountdat[,1:5175],MARGIN = 1,index = "shannon")%>% 
  as.data.frame() %>%
  mutate(Subpop = goodcountdat$Subpop) %>% 
  mutate(Nitrogen = goodcountdat$Nitrogen) %>% 
  mutate(plant_ID = goodcountdat$plant_ID) %>%
  rename(shannon = ".")  %>%
  dplyr::select("plant_ID","Nitrogen","Subpop","shannon")


#NORMALIZED MEDIAN EVENNESS to compare the evenness across samples with relative abundance data
#Propotional measure
#citation: https://journals.asm.org/doi/10.1128/msphere.01019-20
#function
NME <- function(x) {
  y = x[x>0]
  tmp = y * -log(y)
  return(median(tmp)/max(tmp))
} 

diversity.fit$NME <- apply(decostand(goodcountdat[,1:5175],method = "total"),MARGIN = 1, FUN = NME)

#PROPORTION FOUND of total barcodes sequenced in each treatment
#proportional measure
#function which returns the % OF BARCODES FOUND in each site; all columns represent all of the barcodes sequenced in the sample
recovered <- function(row) {
  numzeros <- sum(row == 0)
  prop_not_zero <- 1 - (numzeros / length(row))
  return(prop_not_zero)
} 

diversity.fit$recovered <- apply(goodcountdat[,1:5175], MARGIN = 1, FUN = recovered)

#RICHNESS for the number of barcodes found in each sample
#count measure
diversity.fit$richness <- specnumber(goodcountdat[,1:5175])
```


###Comparison among treatments for each diversity index
```{r}
#Statistical analysis of alphadiv data

#grouped and meaned for reporting mean and SE
diversityfit_anova_data <- diversity.fit %>%
  group_by(Nitrogen, Subpop) %>%
  summarize(Mean_Shannon = mean(shannon),
    SE_Shannon = sd(shannon) / sqrt(n()),
    Mean_NME = mean(NME),
    SE_NME = sd(NME) / sqrt(n()),
    Mean_recovered = mean(recovered),
    SE_recovered = sd(recovered) / sqrt(n()),
    Mean_Richness = mean(richness),
    SE_Richness = sd(richness) / sqrt(n())
  ) 

#kruskal tests to determine if biodiversity measures vary significantly by group

#join Ntreatment and Subpop into single group id for kruskal tests
diversity.fit <- diversity.fit %>%
  mutate(group = paste(Nitrogen, Subpop, sep = "_")) 

kruskal_shannon <- kruskal.test(shannon ~ group, data = diversity.fit)
kruskal_NME <- kruskal.test(NME ~ group, data = diversity.fit)
kruskal_richness <- kruskal.test(richness ~ group, data = diversity.fit)

kruskal_pvals <- c(0.7476, 0.7765, 0.1823)

kruskal_q <- p.adjust(kruskal_pvals, method = "fdr")
```


##Read in metadata for S. meliloti genome
###Create resemblance matrices for downstream analyses
```{r Chunk 3: Resemblance matrices}

#fitmetadata describes genes in detail--locus id, name, cog category, description, essentiality for nodulation, etc etc. 
fitmetadata <- read.csv("C:/Users/User/Desktop/analyze_Nfitness/smeliplant_neutral_cog_clean.csv")

#fitmetadata <- read.csv("~/Github/rhizo.rb.tnseq/Scripts/reciprocal_BLAST_essentiality/rbh_essentiality_supplies/smeliplant_neutral_cog_clean.csv")

#to subset N metabolism genes, a blastKOALA annotation was conducted and N metabolism genes pulled from the KEGG reconstruction
nitrogengenes <- read.delim("C:/Users/User/Desktop/blastkoala_annotation_smeli.txt", header=FALSE)
#nitrogengenes <- read.delim("~/Github/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/blastkoala_annotation_smeli.txt", header=FALSE)


#clean up empty col, remove description info from labels
fitmetadata <- fitmetadata[, -c(1)]
newnamesfitrel <- trimws(row.names(goodfitdat))
row.names(goodfitdat) <- newnamesfitrel 
nitrogengenes$V1 <- trimws(nitrogengenes$V1)

#fitness data subsetted into groups of interest
completefit <- merge(fitmetadata, goodfitdat, by.x = 1, by.y = 0)
nodESfit <- subset(completefit, essentiality=="essential")
nodNEfit <- subset(completefit, essentiality=="N") 

#these gene IDs are from Nmetabolismlist.txt, which is sourced from blastKOALA output
metabloci <- c("SMa0228", "SMc04028", "SMc04026", "SMa1250", "SM_b20986", "SMa1182", "SMc02150", "SMa0697", "SMc04083", "SMa0045", "SMc02613", "SMc00762", "SMc00948", "SMc01594", "SMc01973", "SMc02352", "SM_b20745", "SMa1276", "SMa1236", "SMa1233", "SM_b20436", "SMa0827", "SMa0825", "SMa0829", "SMa1273", "SMc04085", "SMa0585", "SMa0583", "SMa0581", "SM_b20985", "SM_b20984") 

#N metabolism fitness subset
Nmetabolismfit <- subset(completefit, completefit$locus_tag %in% metabloci) 

#save a version of the matrices which preserves metadata to be subsetted by COG in later analyses
COGnodES <- nodESfit
COGnodNE <- nodNEfit
COGcomplete <- completefit
COGNmetabolism <- Nmetabolismfit 
#KEGG df clones to preserve metadata for later
KEGGnodES <- nodESfit
KEGGnodNE <- nodNEfit
KEGGcomplete <- completefit
KEGGNmetabolism <- Nmetabolismfit 

#remove metadata from subsetted groups to get only the numerical data in the frame itself
nodESfit <- nodESfit[, -c(2:20)]
nodNEfit <- nodNEfit[, -c(2:20)]
completefit <- completefit[, -c(2:20)]
Nmetabolismfit <- Nmetabolismfit[, -c(2:20)] 

#update names and deletes extra row
row.names(nodESfit) <- nodESfit[,1]
nodESfit <- nodESfit[, -c(1)]
row.names(nodNEfit) <- nodNEfit[,1]
nodNEfit <- nodNEfit[, -c(1)]
row.names(completefit) <- completefit[,1]
completefit <- completefit[, -c(1)]
row.names(Nmetabolismfit) <- Nmetabolismfit[,1]
Nmetabolismfit <- Nmetabolismfit[, -c(1)] 

#need to be flipped to this orientation for cluster diagrams etc
nodESfit <- t(nodESfit)
nodNEfit <- t(nodNEfit)
completefit <- t(completefit)
Nmetabolismfit <- t(Nmetabolismfit) 

#relabel pots to include pot number and treatment/compartment info all in one
potlabels <- c("1_nodN", "2_nodN", "3_nodN", "4_nodN", "6_nodamb", "7_nodamb", "8_nodamb", "9_nodamb", "0_nodamb", "1_bactN", "2_bactN", "3_bactN", "5_bactN", "7_bactamb", "0_bactamb", "t0", "t0", "t0", "t0", "t0") 

row.names(nodESfit) <- potlabels
row.names(nodNEfit) <- potlabels
row.names(completefit) <- potlabels
row.names(Nmetabolismfit) <- potlabels 

#resemblance matrices
dissim_nodES <- vegdist(nodESfit, method = "euclid", diag = FALSE)
dissim_nodNE <- vegdist(nodNEfit, method = "euclid", diag = FALSE)
dissim_complete <- vegdist(completefit, method = "euclid", diag = FALSE)
dissim_Nmetabolism <- vegdist(Nmetabolismfit, method = "euclid", diag = FALSE) 

#autoscaled matrices for kmo/bartlett tests (need to be scaled before making final cor matrices for tests)
scaled_nodES <- scale(nodESfit)
scaled_nodNE <- scale(nodNEfit)
scaled_complete <- scale(completefit)
scaled_Nmetabolism <-scale(Nmetabolismfit) 

#correlation matrices for downstream statistical analyses
cor_nodES <- cor(scaled_nodES)
cor_nodNE <- cor(scaled_nodNE)
cor_complete <- cor(scaled_complete)
cor_Nmetabolism <- cor(scaled_Nmetabolism) 

#scaled matrices without t0 for permanova, PCA, etc
finalscaled_nodES <- as.data.frame(scaled_nodES[1:(nrow(scaled_nodES) - 5),])
finalscaled_nodNE <- as.data.frame(scaled_nodNE[1:(nrow(scaled_nodNE) - 5),])
finalscaled_complete <- as.data.frame(scaled_complete[1:(nrow(scaled_complete) - 5),])
finalscaled_Nmetabolism <- as.data.frame(scaled_Nmetabolism[1:(nrow(scaled_Nmetabolism) - 5),]) 
```

``` {r Chunk 4: Coverage analysis}

#strain fitness data processing for coverage analysis
strain_fitness <- read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/strain_fit.tab")
pastEnd_count <- strain_fitness %>%
  summarise(count = sum(grepl("pastEnd", scaffold))) #how many barcodes are discarded because insertion site is too early/late
notgene_count <- strain_fitness %>%
  summarise(count = sum(locusId == "")) #how many barcodes are discarded because they are not inserted in a gene
used_count <- strain_fitness %>%
  summarise(count = sum(used == "TRUE")) #how many barcodes are used to calculate gene fitness scores
used_fitness <- strain_fitness %>%
  filter(used == "TRUE") #data for used subset


#get raw reads data and remove unused samples
allcounts <- read.delim("C:/Users/User/Desktop/Research and Literature and others/thesis_stuff/barseq_landing/g/SmeliPlant/SmeliPlant.poolcount")
allcounts <- allcounts[, -c(6:25)] #remove soil samples
allcounts <- allcounts %>%
  dplyr::select(-c(IT025, IT034, IT036, IT038, IT039)) #remove unused plant samples


#get other pool file to steal locus IDs and used status from it
barcode_status <- strain_fitness %>%
  dplyr::select(barcode, used)
allcounts <- allcounts %>%
  left_join(barcode_status, by = "barcode")
allcounts <- allcounts %>%
  relocate(used, .after = pos)

poolcount_master <- read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/all.poolcount") 
locusid_status <- poolcount_master %>% dplyr::select(barcode, locusId)
allcounts <- allcounts %>% left_join(locusid_status, by = "barcode")
allcounts <- allcounts %>%
  relocate(locusId, .after = used)

#separate out barcodes which got no reads in any experimental treatment
barcodes_noreads <- allcounts %>%
  filter(if_all(8:22, ~ .x == 0))
noreads_counts <- barcodes_noreads %>%
  count(used)

#these are the ones that did get nonzero reads
barcodes_somereads <- allcounts %>%
  filter(if_any(8:22, ~ .x != 0))
somereads_counts <- barcodes_somereads %>%
  count(used)

#count genes and find out which/how many are represented in each set
noreads_locus_count <- n_distinct(barcodes_noreads$locusId)
somereads_locus_count <- n_distinct(barcodes_somereads$locusId)
noreads_unique_ids <- barcodes_noreads %>%
  distinct(locusId)
somereads_unique_ids <- barcodes_somereads %>%
  distinct(locusId)

#locus IDs unique to the no reads group
unique_to_noreads <- noreads_unique_ids %>%
  anti_join(somereads_unique_ids, by = "locusId")

#number of genes which got some reads
somereads_used_locus_count <- barcodes_somereads %>%
  filter(used == TRUE) %>%
  summarise(distinct_locus_ids = n_distinct(locusId))

#summary of barcode coverage for each gene
coverage_stats <- strain_fitness %>%
  group_by(locusId) %>%
  summarise(
    total_barcodes = n(),
    used_count = sum(used),
    percentUsed = (used_count / total_barcodes) * 100,
    percentDiscarded = 100 - percentUsed,
    .groups = 'drop'
  ) %>%
  dplyr::select(locusId, percentUsed, percentDiscarded) %>%
  column_to_rownames(var = "locusId")

#calculate barcode recovery %s for each gene to add to coverage_stats later
found_stats <- allcounts %>%
  group_by(locusId) %>%
  summarise(
    nonzero_count = sum(across(IT021:IT040, ~ .x != 0)), #how many nonzero cells in this range
        total_cells = n() * 15,
        `found%` = (nonzero_count / total_cells) * 100,  #proportion of nonzero vs total
    howmanyBCs = n(),
    .groups = 'drop'
  ) %>%
  dplyr::select(locusId, `found%`, howmanyBCs)

#add to coverage_stats
coverage_stats <- coverage_stats %>%
  rownames_to_column(var = "locusId") %>%
  left_join(found_stats, by = "locusId") %>%
  column_to_rownames(var = "locusId")

#final list of loci with solid results
final_locus_list <- coverage_stats %>%
  rownames_to_column(var = "locusId") %>%
    filter(howmanyBCs >= 5) %>% #more than 5 total barcodes recovered
    mutate(product = howmanyBCs * (`found%` / 100)) %>%
    filter(product >= 1) %>% #more than 1 average per replicate
    pull(locusId)
final_locus_list <- final_locus_list[-1] #remove empty locus

#counts
goodcoverage_count <- strain_fitness %>%
  summarise(count = sum(locusId %in% final_locus_list & used == TRUE))


```


##PERMANOVA analyses testing for effects of nitrogen treatment and subpopulation on gene-level fitness
```{r Chunk 4: PERMANOVAs}

#remove t0 from original dfs
covar_nodES <- as.data.frame(nodESfit[1:(nrow(scaled_nodES) - 5),])
covar_nodNE <- as.data.frame(nodNEfit[1:(nrow(scaled_nodES) - 5),])
covar_complete <- as.data.frame(completefit[1:(nrow(scaled_nodES) - 5),])
covar_Nmetab <- as.data.frame(Nmetabolismfit[1:(nrow(scaled_nodES) - 5),]) 
finalmetadat <- metadat[-c((nrow(metadat) - 4):nrow(metadat)), ]


#PERMANOVA with FDR adjustment
nodES_covar_permanova <- adonis2(covar_nodES ~ finalmetadat$Nitrogen_addition + finalmetadat$Subpop + finalmetadat$plantID, data = covar_nodES, permutations = 9999, by = "terms", method="euclidean")

nodNE_covar_permanova <- adonis2(covar_nodNE ~ finalmetadat$Nitrogen_addition + finalmetadat$Subpop + finalmetadat$plantID, data = covar_nodNE, permutations = 9999, by = "terms",  method="euclidean")

complete_covar_permanova <- adonis2(covar_complete ~ finalmetadat$Nitrogen_addition + finalmetadat$Subpop + finalmetadat$plantID, data = covar_complete, permutations = 9999, by = "terms",  method="euclidean")

Nmetab_covar_permanova <- adonis2(covar_Nmetab ~ finalmetadat$Nitrogen_addition + finalmetadat$Subpop + finalmetadat$plantID, data = covar_Nmetab, permutations = 9999, by = "terms",   method="euclidean")

nodES_covar_permanova
nodNE_covar_permanova
complete_covar_permanova
Nmetab_covar_permanova

#in these permanovas, subpop was highly insignificant while N level and pot ID were significant. Rerunning models with just N addition and plant ID:

nodES_covar_permanova <- adonis2(covar_nodES ~ finalmetadat$Nitrogen_addition + finalmetadat$plantID, data = covar_nodES, permutations = 9999, by = "terms", method="euclidean")

nodNE_covar_permanova <- adonis2(covar_nodNE ~ finalmetadat$Nitrogen_addition + finalmetadat$plantID, data = covar_nodNE, permutations = 9999, by = "terms",  method="euclidean")

complete_covar_permanova <- adonis2(covar_complete ~ finalmetadat$Nitrogen_addition + finalmetadat$plantID, data = covar_complete, permutations = 9999, by = "terms",  method="euclidean")

Nmetab_covar_permanova <- adonis2(covar_Nmetab ~ finalmetadat$Nitrogen_addition + finalmetadat$plantID, data = covar_Nmetab, permutations = 9999, by = "terms",   method="euclidean")

nodES_covar_permanova
nodNE_covar_permanova
complete_covar_permanova
Nmetab_covar_permanova

all_permanova_results <- lst(
  nodES_covar_permanova,
  nodNE_covar_permanova,
  complete_covar_permanova,
  Nmetab_covar_permanova
)

#FDR adjustment, collect permanova results into tables for later plotting
raw_pvals <- map(all_permanova_results, ~ .x$`Pr(>F)`[1:2]) %>% unlist()
adjusted_qvals <- p.adjust(raw_pvals, method = "fdr") #fdr adjustment

#create summary table reporting permanova results with q-values
results_table <- map_dfr(
  .x = all_permanova_results,
  .f = function(permanova_df) {
    permanova_df %>%
      slice(1:2) %>% #keep only the two rows containing interaction term data
      dplyr::select(R2, F, p_value = `Pr(>F)`) %>%
      mutate(
        term = c("Nitrogen_addition", "plantID"), 
        .before = 1
      )
  },
  .id = "source_test" #creates a column with the name of the test
) %>%
  #add q-values
  mutate(q_value = adjusted_qvals)


#check dispersion on permanovas real quick
finalmetadat <- finalmetadat %>%
  mutate(group = paste(Subpop, Nitrogen_addition, sep = "_"))

permanova_dispersions <- vegdist(covar_complete, method = "euclid", diag = FALSE)
perm_dispersion <- betadisper(permanova_dispersions, group = finalmetadat$group)
permutest(perm_dispersion)

permanova_nodES_dispersions <- vegdist(covar_nodES, method = "euclid", diag = FALSE)
perm_nodES_dispersion <-  betadisper(permanova_nodES_dispersions, group = finalmetadat$group)
permutest(perm_nodES_dispersion)

permanova_nodNE_dispersions <- vegdist(covar_nodNE, method = "euclid", diag = FALSE)
perm_nodNE_dispersion <-  betadisper(permanova_nodNE_dispersions, group = finalmetadat$group)
permutest(perm_nodNE_dispersion)

```


##Generate gene fitness rankings and conduct Spearman correlation tests on ranking
```{r Chunk 5: Ranked fitness, K-S, Rank-order correlation tests}

#set up row names and such to be merged and unmerged
RACmetadata <- metadat
RACmetadata <- RACmetadata[-c(16:20), ] #remove t0
row.names(RACmetadata) <- c("021", "022", "023", "024", "026", "027", "028", "029", "030", "031", "032", "033", "035", "037", "040")
row.names(goodcountdat) <- c("021", "022", "023", "024", "026", "027", "028", "029", "030", "031", "032", "033", "035", "037", "040")
RACdat <- goodcountdat[, -c(5176:5178)]

#merged metadata/data df for re-subsetting and creating fitness rankings etc
RACsubsetter <- as.data.frame(cbind(RACmetadata, RACdat))
RACsubsetter <- RACsubsetter %>%
  mutate(across(16:5190, as.numeric)) #numeric data should be classed as numeric

#create a properly labeled and formatted dataframe to be grouped and meaned by treatment/compartment
rankfitdata <- t(goodfitdat)
rankfitdata <- rankfitdata[-c(1:2), ]
row.names(rankfitdata) <- c("021", "022", "023", "024", "026", "027", "028", "029", "030", "031", "032", "033", "035", "037", "040", "041", "042", "043", "044", "045")
rankfitdata <- cbind(RACsubsetter$Nitrogen_addition, rankfitdata)
rankfitdata <- as.data.frame(rankfitdata)
rankfitdata$V1[16:20] <- c("t0", "t0", "t0", "t0", "t0")
rankfitdata <- rankfitdata %>%
  mutate(V1 = case_when(
    V1 == "2" ~ "1",
    V1 == "1" ~ "0",
    TRUE ~ V1
  )) #for some reason, the cbind added 1 to all the Nitrogen_addition values, so this must undo that
rankfitdata <- rankfitdata %>%
  mutate(across(2:5176, as.numeric)) 


rankfitdata <- rankfitdata %>%
  dplyr::select(
    1, # Keep the first column
    all_of(intersect(colnames(.)[2:5176], final_locus_list)) #filter rankings to exclude genes with poor coverage
  )


#table of meaned gene fitness per treatment/compartment group
meanfitnessrank <- rankfitdata %>%
  group_by(V1) %>%
  summarise(across(starts_with("SM"), mean)) 

#clean up and relabels rows by treatment/compartment group, make whole-genome gene fitness rank
meanfitnessrank <- as.data.frame(meanfitnessrank)
row.names(meanfitnessrank) <- meanfitnessrank[,1]
meanfitnessrank <- meanfitnessrank[,-1] 

#subsets
meanfitnessrank_Nmetab <- meanfitnessrank[, intersect(colnames(meanfitnessrank), metabloci)]
meanfitnessrank_nodNE <- meanfitnessrank[, intersect(colnames(meanfitnessrank), colnames(nodNEfit))]
meanfitnessrank_nodES <- meanfitnessrank[, intersect(colnames(meanfitnessrank), colnames(nodESfit))]  
#NOTE: will add subsets here for recovered/unrecovered genes as determined by coverage analysis

#fitness rankings for the whole genome
ambrank <-unlist(meanfitnessrank[1,])
fertrank <- unlist(meanfitnessrank[2,])
t0rank <- unlist(meanfitnessrank[3,])


#version of the RAC function designed to rank fitness scores, which have negative and positive values
rankfit <- function(x) {
  x <- as.data.frame(x)
  x.ranked <- x[order(rownames(x)), , drop = FALSE]
  rownames(x.ranked) <- rownames(x)[order(rownames(x))]
  return(x.ranked)
} 

ranked_amb <- rankfit(ambrank)
ranked_fert <- rankfit(fertrank)
ranked_t0 <- rankfit(t0rank)

#fitness rankings for the N metabolism gene set only
Nmetab_ambrank <-unlist(meanfitnessrank_Nmetab[1,])
Nmetab_fertrank <- unlist(meanfitnessrank_Nmetab[2,])
Nmetab_t0rank <- unlist(meanfitnessrank_Nmetab[3,])

ranked_Nmetab_amb <- rankfit(Nmetab_ambrank)
ranked_Nmetab_fert <- rankfit(Nmetab_fertrank)
ranked_Nmetab_t0 <- rankfit(Nmetab_t0rank)

#NE
nodNE_ambrank <- unlist(meanfitnessrank_nodNE[1,])
nodNE_fertrank <- unlist(meanfitnessrank_nodNE[2,])
nodNE_t0rank <- unlist(meanfitnessrank_nodNE[3,])

ranked_nodNE_amb <- rankfit(nodNE_ambrank)
ranked_nodNE_fert <- rankfit(nodNE_fertrank)
ranked_nodNE_t0 <- rankfit(nodNE_t0rank)

#ES
nodES_ambrank <- unlist(meanfitnessrank_nodES[1,])
nodES_fertrank <- unlist(meanfitnessrank_nodES[2,])
nodES_t0rank <- unlist(meanfitnessrank_nodES[3,])

ranked_nodES_amb <- rankfit(nodES_ambrank)
ranked_nodES_fert <- rankfit(nodES_fertrank)
ranked_nodES_t0 <- rankfit(nodES_t0rank)

#combine
combined_nodES <- data.frame(
  amb = ranked_nodES_amb$x,
  fert = ranked_nodES_fert$x
)  
#match row names
rownames(combined_nodES) <- rownames(ranked_nodES_amb) 


combined_nodNE <- data.frame(
  amb = ranked_nodNE_amb$x,
  fert = ranked_nodNE_fert$x
)
rownames(combined_nodNE) <- rownames(ranked_nodNE_amb)


combined_complete <- data.frame(
  amb = ranked_amb$x,
  fert = ranked_fert$x
)
rownames(combined_complete) <- rownames(ranked_amb)

combined_Nmetab <- data.frame(
  amb = ranked_Nmetab_amb$x,
  fert = ranked_Nmetab_fert$x
)
rownames(combined_Nmetab) <- rownames(ranked_Nmetab_amb)



#run K-S tests on data

#function to re-sort fitness rankings from genome order (for spearman) to ascending order (for k-s tests)
ks_sort <- function(my_ranking) {
  sorted_list <- my_ranking[order(my_ranking, decreasing = TRUE)]
  name <- paste0("ks_", deparse(substitute(my_ranking)))
  names(sorted_list) <- name
  return(sorted_list)
} 

#gather all the rankings together for reordering
all_ranked <- ls(pattern = "^ranked_") 

#for loop which calls ks_sort on all the rankings. Don't know why the redundant paste0(ks_) is needed, but it is!!
for (name in all_ranked) {
  ranked_obj <- get(name)
  if (is.data.frame(ranked_obj)) {
    ranked_vec <- ranked_obj[, 1]
  } else {
    ranked_vec <- ranked_obj
  }
  sorted_vec <- ks_sort(ranked_vec)
  assign(paste0("ks_", name), sorted_vec)
} 

#whole genome ranked fitness K-S test
ks_fit <- ks.test(ks_ranked_amb, ks_ranked_fert, exact = TRUE)

#combined RAC-like fitness ranking plot for whole genome
finalfitrank_complete <- as.data.frame(rbind(as.numeric(ks_ranked_amb), as.numeric(ks_ranked_fert), as.numeric(ks_ranked_t0)))
colnames(finalfitrank_complete) <- 1:2863
finalfitrank_complete$treatment <- c("amb", "fert", "t0")

finalfitrank_complete <- pivot_longer(finalfitrank_complete, cols = colnames(finalfitrank_complete)[1:2863])

combinedfitrank_complete <- ggplot(finalfitrank_complete, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
  geom_line() +
  labs(title = "Whole-genome rank-fitness curves")  + xlab("Fitness ranking [1-5175]") + ylab("Fitness score [log2 ratio]")


#PUB VERSION

combinedfitrank_complete <- ggplot(finalfitrank_complete, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
   geom_line(size = 0.9) +  # Increase the thickness of the lines
   labs(title = "Whole-genome rank-fitness curves") +
   xlab("Fitness ranking [1-5175]") +
   ylab("Fitness score [log2 ratio]") +
   scale_color_manual(values = c("amb" = "firebrick", "fert" = "steelblue", "t0" = "black")) + # Custom colors for each treatment
   scale_fill_manual(values = c("amb" = "firebrick", "fert" = "steelblue", "t0" = "black")) + # Fill colors for lines
   theme_bw(base_size = 20) +  # Increase base font size
   theme(
     panel.grid.major = element_line(color = "gray", size = 0.5),  # Light gray grid lines
     panel.grid.minor = element_line(color = "gray", size = 0.25),  # Fainter minor grid lines
     panel.border = element_rect(linewidth = 2, colour = "black", fill = NA), # Thicker border
     panel.background = element_rect(fill = "white"),
     plot.background = element_rect(fill = "white"),
     axis.text.x = element_text(size = 14, colour = "black"),  # Larger and black tick labels on X-axis
     axis.text.y = element_text(size = 14, colour = "black"),  # Larger and black tick labels on Y-axis
     axis.title.x = element_text(size = 16, face = "bold", colour = "black"),  # Larger and bold X-axis title
     axis.title.y = element_text(size = 16, face = "bold", colour = "black"),  # Larger and bold Y-axis title
     legend.text = element_text(size = 14),  # Larger legend text
     legend.title = element_text(size = 16, face = "bold")  # Larger and bold legend title
   )

combinedfitrank_complete


#Spearman correlation tests for rankfit paired datasets

#ES
spearman_nodES <- cor.test(combined_nodES$amb, combined_nodES$fert, method = "spearman")
#NE
spearman_nodNE <- cor.test(combined_nodNE$amb, combined_nodNE$fert, method = "spearman")
#complete
spearman_complete <- cor.test(combined_complete$amb, combined_complete$fert, method = "spearman")
#Nmetabolism
spearman_Nmetab <- cor.test(combined_Nmetab$amb, combined_Nmetab$fert, method = "spearman")


#plot for each genome partition
plot_nodES <- ggplot(data = combined_nodES, aes(x = amb, y = fert)) +
  geom_point(alpha = 0.6, color = "#0072B2") +
  geom_smooth(method = "loess", color = "#D55E00", se = FALSE) +
  labs(
    title = "Gene Fitness Correlation: nodES",
    subtitle = paste("Spearman's rho =", round(spearman_nodES$estimate, 2),
                     "| p-value =", format.pval(spearman_nodES$p.value, digits = 2)),
    x = "Ambient Condition Fitness",
    y = "Fertilized Condition Fitness"
  ) +
  theme_minimal(base_size = 14)

plot_nodNE <- ggplot(data = combined_nodNE, aes(x = amb, y = fert)) +
  geom_point(alpha = 0.6, color = "#0072B2") +
  geom_smooth(method = "loess", color = "#D55E00", se = FALSE) +
  labs(
    title = "Gene Fitness Correlation: nodNE",
    subtitle = paste("Spearman's rho =", round(spearman_nodNE$estimate, 2),
                     "| p-value =", format.pval(spearman_nodNE$p.value, digits = 2)),
    x = "Ambient Condition Fitness",
    y = "Fertilized Condition Fitness"
  ) +
  theme_minimal(base_size = 14)

plot_complete <- ggplot(data = combined_complete, aes(x = amb, y = fert)) +
  geom_point(alpha = 0.6, color = "#0072B2") +
  geom_smooth(method = "loess", color = "#D55E00", se = FALSE) +
  labs(
    title = "Gene Fitness Correlation: Complete Genome",
    subtitle = paste("Spearman's rho =", round(spearman_complete$estimate, 2),
                     "| p-value =", format.pval(spearman_complete$p.value, digits = 2)),
    x = "Ambient Condition Fitness",
    y = "Fertilized Condition Fitness"
  ) +
  theme_minimal(base_size = 14)

plot_Nmetab <- ggplot(data = combined_Nmetab, aes(x = amb, y = fert)) +
  geom_point(alpha = 0.6, color = "#0072B2") +
  geom_smooth(method = "loess", color = "#D55E00", se = FALSE) +
  labs(
    title = "Gene Fitness Correlation: N Metabolism",
    subtitle = paste("Spearman's rho =", round(spearman_Nmetab$estimate, 2),
                     "| p-value =", format.pval(spearman_Nmetab$p.value, digits = 2)),
    x = "Ambient Condition Fitness",
    y = "Fertilized Condition Fitness"
  ) +
  theme_minimal(base_size = 14)



```


```{r Chunk 7: Compositional PCA + plots}

#impute values for zeroes in data after filtering out very low-abundance genes
goodcountdat_filtered <- goodcountdat %>%
  dplyr::select(any_of(final_locus_list)) %>%
  as.data.frame()

detection_limit <- 0.5
goodcountdat_imputed <- multRepl(goodcountdat_filtered, 
                         label = 0, 
                         dl = rep(detection_limit, ncol(goodcountdat_filtered)))
goodcountdat_clr <- decostand(goodcountdat_imputed, method = "clr")

PCA_wholegenome_filtered <- rda(goodcountdat_clr)


pca_summary <- summary(PCA_wholegenome_filtered)
head(scores(PCA_wholegenome_filtered))
quick_biplot <- biplot(PCA_wholegenome_filtered)

simple_PCA_plot <- plot(PCA_wholegenome_filtered, display = "sites", main = "PCA of Samples (PC1 vs PC2)")


pca_scores <- scores(PCA_wholegenome_filtered, display = "sites") %>%
  as_tibble(rownames = "sample_id")
pca_scores$sample_id <- finalmetadat$Barseq_Index
pca_scores <- pca_scores %>%
  rename(Barseq_Index = sample_id)

#combine scores with metadata
plot_data <- pca_scores %>%
  left_join(finalmetadat, by = "Barseq_Index")

plot_data <- plot_data %>%
  mutate(Nitrogen_level = factor(ifelse(Nitrogen_addition == 1, "+N", "-N")))

#variance explained by PC1 and PC2
pc1_variance <- round(pca_summary$cont$importance["Proportion Explained", "PC1"] * 100, 1)
pc2_variance <- round(pca_summary$cont$importance["Proportion Explained", "PC2"] * 100, 1)


ggplot(plot_data, aes(x = PC1, y = PC2, fill = as.factor(Nitrogen_addition))) + 
  geom_point(shape = 21, size = 9, stroke = 1.5, color = "black") + 
  xlab(paste0("PC1 (", pc1_variance, "%)")) +
  ylab(paste0("PC2 (", pc2_variance, "%)")) +
  scale_fill_manual( 
    name = "Nitrogen",
    values = c("0" = "#56B4E9", "1" = "#E69F00"), 
    labels = c("0" = "-N", "1" = "+N")
  ) +
  xlim(c(-10, 10)) +
  ylim(c(-10, 10)) +
  theme_bw(base_size = 30) +
  theme(
    panel.grid = element_blank(),
    panel.border = element_rect(linewidth = 5, colour = "black", fill = NA),
    axis.text = element_text(size = rel(1.5)),
    axis.title = element_text(size = 40),
    axis.ticks = element_line(linewidth = 3),
    axis.ticks.length = unit(0.4, "cm"),
    legend.position = "right",
    legend.title = element_text(size = 22),
    legend.text = element_text(size = 20)
  )

```


```{r Chunk 13: Gene-level ANOVAs}

#gene-level type iii anova analysis

ANOVAcomplete <- COGcomplete

#remove t0 and extraneous info
ANOVAcomplete <- ANOVAcomplete[, -c(36:40)] 
ANOVAfitness <- ANOVAcomplete[, c(1, 21:35)]
anovastrata <- potlabels[-c(16:20)]
rownames(ANOVAfitness) <- ANOVAfitness$locus_tag
ANOVAfitness <- t(ANOVAfitness[, -c(1)])

#define treatment groups
ANOVAfitness <- data.frame(Ntreatment = c(rep("fertilized",4), rep("ambient",5),rep("fertilized", 4), rep("ambient", 2)), 
                            compartment = c(rep("nodule",9), rep("bacteroid",6)),
                            strata = anovastrata, ANOVAfitness)

#run gene-level anovas on each gene in the genome testing for effects of N treatment and subpopulation
anovafit_results <- new.env()

for (i in 4:ncol(ANOVAfitness)) { #start here to avoid metadata columns
    col_name <- colnames(ANOVAfitness)[i]
    formula <- as.formula(paste(col_name, "~ Ntreatment/compartment")) #anova formula
    anova_result <- Anova(lm(formula, data = ANOVAfitness), type = 'III') #runs anova
    assign(col_name, anova_result, envir = anovafit_results) #stores in results env
}

#remove intercept pval
for (obj_name in ls(anovafit_results)) {
    result <- anovafit_results[[obj_name]]
    anovafit_results[[obj_name]] <- result[-c(1, nrow(result)), ]
}

#extract p-values for each factor separately
ntreatment_pvals <- unlist(lapply(anovafit_results, function(df) df["Ntreatment", "Pr(>F)"]))
compartment_pvals <- unlist(lapply(anovafit_results, function(df) df["compartment", "Pr(>F)"]))

#fdr adjustment for each factor
adjusted_ntreatment_pvals <- p.adjust(ntreatment_pvals, method = "fdr")
adjusted_compartment_pvals <- p.adjust(compartment_pvals, method = "fdr")

#update anovafit_results
for (obj_name in ls(anovafit_results)) {
    result <- anovafit_results[[obj_name]]
    result[result$Term == "Ntreatment", "Pr(>F)"] <- adjusted_ntreatment_pvals
    result[result$Term == "compartment", "Pr(>F)"] <- adjusted_compartment_pvals
    anovafit_results[[obj_name]] <- result
}

#pick out significant results from dataset
anovafit_significant <- new.env()
for (obj_name in ls(anovafit_results)) {
  result <- anovafit_results[[obj_name]] #goes through and picks out significant results

  if (any(result$"Pr(>F)"[1:2] < 0.2)) { #only retrieve qvals under the threshold for at least one factor
    assign(obj_name, result, envir = anovafit_significant)
  }
}

```


```{r Chunk 14: Spots_Moved analysis}

#The purpose of this is to provide a roughest possible quantification of the change in fitness for each gene in the genome by nitrogen level. This is done by comparing the fitness rankings for each condition and determining how many spots up or down each gene moved in the ranking between each treatment.

spotsmoved_df <- combined_complete
spotsmoved_df <- rownames_to_column(spotsmoved_df, var = "gene_locus")
treatment_columns <- c("amb", "fert")

#split into individual objects by treatment
for (treatment in treatment_columns) {
  new_df_name <- paste0(treatment, "_spotsmoved")
  temp_df <- spotsmoved_df %>%
    dplyr::select(gene_locus, all_of(treatment))
  assign(new_df_name, temp_df)
}

#sort from greatest to least
spotsmoved_each <- ls(pattern = "_spotsmoved$")

for (df_name in spotsmoved_each) {
  current_df <- get(df_name)

  score_column_name <- names(current_df)[2]
  sorted_df <- current_df %>%
    arrange(desc(!!sym(score_column_name)))
  assign(df_name, sorted_df)
}

#spots moved

amb_spots_sorted <- amb_spotsmoved %>% mutate(rank_amb = row_number())
fert_spots_sorted <- fert_spotsmoved %>% mutate(rank_fert = row_number())

#join by locus tag
comparison_df <- amb_spots_sorted %>%
  inner_join(fert_spots_sorted, by = "gene_locus") %>%
  mutate(
    spots_moved = rank_amb - rank_fert,
    score_diff = amb - fert #calculate difference in rank between treatments (how many spots moved)
  ) %>%
  arrange(desc(abs(spots_moved))) %>% #arrange by absolute value
  dplyr::select(gene_locus, spots_moved, score_diff)


loci_from_spotsmoved <- unique(comparison_df$gene_locus)
loci_from_anovafit <- ls(anovafit_significant)

#get all the genes flagged as significant by anova
spotsmoved_anovafit_common_genes <- intersect(loci_from_spotsmoved, loci_from_anovafit)
comparison_df_significant <- comparison_df %>%
  filter(gene_locus %in% spotsmoved_anovafit_common_genes)

#add spotsmoved values to the main df
comparison_df_significant <- comparison_df_significant %>%
  mutate(
    p_values = map(gene_locus, function(locus_name) {
      anova_table <- get(locus_name, envir = anovafit_significant)
      
      p_n <- anova_table["Ntreatment", "Pr(>F)"]
      p_subpop <- anova_table["Ntreatment:compartment", "Pr(>F)"]
      
      tibble(padj_N = p_n, padj_subpop = p_subpop)
    })
  ) %>%
  unnest(p_values)

#put it all together
comparison_df_significant_coverage <- comparison_df_significant %>%
  left_join(
    coverage_stats %>% rownames_to_column(var = "gene_locus"),
    by = "gene_locus"
  )

comparison_df_significant_coverage <- comparison_df_significant_coverage %>%
  left_join(
    fitmetadata %>% dplyr::select(locus_tag, 2:18),
    by = c("gene_locus" = "locus_tag")
  )

#filter qvals more stringently if you like
comparison_df_filtered <- comparison_df_significant_coverage %>%
  filter(padj_N <= 0.05)



#replicon analysis

all_colnames <- colnames(covar_complete)

#get all psymA genes
covar_psymA <- covar_complete[, startsWith(all_colnames, "SMa")]

#pSymB
covar_psymB <- covar_complete[, startsWith(all_colnames, "SM_")]

#chromosome
covar_chromosome <- covar_complete[, startsWith(all_colnames, "SMc")]


#permanovas by replicon
chromosome_covar_permanova <- adonis2(covar_chromosome ~ finalmetadat$Nitrogen_addition/finalmetadat$Subpop, data = covar_chromosome, permutations = 9999, by = "terms",  method="euclidean")

psymA_covar_permanova <- adonis2(covar_psymA ~ finalmetadat$Nitrogen_addition/finalmetadat$Subpop + finalmetadat$plantID, data = covar_psymA, permutations = 9999, by = "terms",  method="euclidean")

psymB_covar_permanova <- adonis2(covar_psymB ~ finalmetadat$Nitrogen_addition/finalmetadat$Subpop + finalmetadat$plantID, data = covar_psymB, permutations = 9999, by = "terms", method="euclidean")

chromosome_covar_permanova
psymA_covar_permanova
psymB_covar_permanova


#compare replicon effects 
gene_metadata <- fitmetadata
gene_data_complete <- t(covar_complete)

gene_metadata <- gene_metadata %>%
  mutate(replicon = case_when(
    startsWith(locus_tag, "SMa") ~ "psymA",
    startsWith(locus_tag, "SM_") ~ "psymB",
    startsWith(locus_tag, "SMc") ~ "chromosome"
  )) %>%
  relocate(replicon)

gene_dist <- vegdist(gene_data_complete, method = "euclidean")

gene_metadata <- gene_metadata %>%
  filter(locus_tag %in% rownames(gene_data_complete))

#dispersion test: do plasmid genes show more variable fitness than chromosome genes?

# dispersal_test <- betadisper(gene_dist, group = gene_metadata$replicon)
# permutest(dispersal_test)
# 
# library(RVAideMemoire)
# 
#pairwise post-hoc test
# pairwise_replicons <- pairwise.perm.manova(resp = gene_dist, 
#                                           fact = gene_metadata$replicon, 
#                                           p.method = "fdr")
#
# gene_metadata_chromvsacc <- gene_metadata %>%
#   mutate(replicon_binned = ifelse(startsWith(locus_tag, "SMc"), "chromosome", "plasmid")) %>%
#   relocate(replicon_binned)
# 
# chromosome_vs_accessory <- vegan::adonis2(
#   gene_dist ~ replicon_binned, 
#   data = gene_metadata_chromvsacc,
#   permutations = 999
# )
# 
# chromosome_vs_accessory



```

``` {R chunk ##: Sankey chart for visualizing coverage}

library(networkD3)

nodes_barcodes <- data.frame(
  name = c(
    "Raw Total Barcodes (140,593)",                 #node 0
    "Total Barcodes (113,721)",                     #1
    "Removed: Non-gene\ninsertions (26,872)",       #2
    "Potentially Useful Barcodes (112,673)",        #3
    "Removed: pastEnd\ninsertions (1,048)",         #4
    "Used Barcodes (83,934)",                       #5
    "Removed: Other Unused\nBarcodes (28,739)"      #6
  ),
  group = c("Start", "Kept", "Removed", "Kept", "Removed", "Final", "Removed")
)

#nodes are designated as 'source' and/or 'target' depending on entries/exits from the node
links_barcodes <- data.frame(
  source = c(0, 0, 1, 1, 3, 3),
  target = c(1, 2, 3, 4, 5, 6),
  value = c(113721, 26872, 112673, 1048, 83934, 28739)
)

#make barcode chart
color_scale_barcodes <- 'd3.scaleOrdinal().domain(["Start", "Kept", "Removed", "Final"]).range(["#4682B4", "#87CEEB", "#FFA07A", "#2E8B57"])' #SteelBlue, SkyBlue, LightSalmon, SeaGreen

sankey_barcodes <- sankeyNetwork(
  Links = links_barcodes,
  Nodes = nodes_barcodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  colourScale = color_scale_barcodes,
  units = "barcodes",
  fontSize = 14,
  nodeWidth = 30,
  sinksRight = FALSE,
  iterations = 0, 
  margin = list(top = 75, bottom = 75)
)

print(sankey_barcodes)

#gene chart
nodes_genes <- data.frame(
  name = c(
    "Barcodes pooled into genes (4806)",                    
    "Final Gene Count (2863)",                                  
    "Removed: Genes with low barcode\ncounts or <1 avg read (1943)",        
    "Genes which changed in fitness\nsignificantly (801)",                  
    "Removed: Nonsignificant genes\nby gene-level ANOVA (2062)"           
  ),
  group = c("Start", "Kept", "Removed", "Final", "Removed")
)

links_genes <- data.frame(
  source = c(0, 0, 1, 1),
  target = c(1, 2, 3, 4),
  value =  c(2863, 1943, 801, 2062)
)

color_scale_genes <- 'd3.scaleOrdinal().domain(["Start", "Kept", "Removed", "Final"]).range(["#4682B4", "#87CEEB", "#FFA07A", "#2E8B57"])'

sankey_genes <- sankeyNetwork(
  Links = links_genes,
  Nodes = nodes_genes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  NodeGroup = "group",
  colourScale = color_scale_genes,
  units = "genes",
  fontSize = 14,
  nodeWidth = 30,
  sinksRight = FALSE,
  iterations = 0,
  margin = list(top = 75, bottom = 75)
)

print(sankey_genes)


```



```{r Chunk 16: Tentative graveyard zone}

#here's all the deprecated code, which I'm keeping here both to show my work and in case anything is needed from here




#Ward's clustering plots (used to get a preliminary sense of the clustering of replicates before in-depth analyses)


# ##Ward's clustering plots to quickly visualize variation between replicates for each partition of the genome
# 
# 
# #quick and easy clustering plots for each genome partition for each pot
# ward_nodES <- hclust(dissim_nodES, method = "ward.D2")
# ward_nodNE <- hclust(dissim_nodNE, method = "ward.D2")
# ward_complete <- hclust(dissim_complete, method = "ward.D2") 
# ward_Nmetabolism <- hclust(dissim_Nmetabolism, method = "ward.D2")
# 
# wardlabels <- paste(goodqual_metadata$compartment, goodqual_metadata$Ntreatment, sep = "_")
# wardlabels <- as.data.frame(wardlabels)
# row.names(wardlabels) <- row.names(goodqual_metadata)
# wardlabels$potID <- c("1_", "2_", "4_", "6_", "7_", "8_", "9_", "10_", "1_", "2_",  "5_", "7_", "10_", "1_", "2_", "3_", "4_", "5_")
# wardlabels <- paste(wardlabels$potID, wardlabels$wardlabels, sep = "")
# 
# par(mar = c(1, 5, 2, 2) + 0.1)
# plot(ward_nodES, main = "Ward's Clustering of sites by essential nodulation gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
# plot(ward_nodNE, main = "Ward's Clustering of sites by nonessential nodulation gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
# plot(ward_complete, main = "Ward's Clustering of sites by whole-genome fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
# plot(ward_Nmetabolism, main = "Ward's Clustering of sites by N metabolism gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)


# 
# #mulEA (evaluating to replace fgsea with this)
# 
# # Get a list of objects ending with "_ranks" in the global environment
# objects <- ls(pattern = "_ranks$", envir = .GlobalEnv)
# 
# # Create a new dataframe for each object with two columns
# for (obj_name in objects) {
#   vec <- get(obj_name, envir = .GlobalEnv)
#   df_name <- paste0(obj_name, "_mulea")
#   assign(df_name, data.frame(names = names(vec), x = vec))
# }
# 
# 
# # Install mulea package if not already installed
# 
# library(devtools)
# # install_github("https://github.com/koralgooll/MulEA.git", force = TRUE)
# require(MulEA)
# 
# # Load KEGG pathway gene set collection
# mulea_keggES <- read_gmt("KEGGsets_ES.gmt")
# mulea_keggNE <- read_gmt("KEGGsets_NE.gmt")
# 
# # Run mulea analysis
# 
# 
# #nodule
# 
# #+N ES
# mulea_N_ES_nod <- gsea(gmt = mulea_keggES,
#                    element_names = nodN_ranks_mulea$names,
#                    element_scores = nodN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_ES_nod_results <- run_test(mulea_N_ES_nod)
# 
# #--N ES
# mulea_amb_ES_nod <- gsea(gmt = mulea_keggES,
#                    element_names = nodamb_ranks_mulea$names,
#                    element_scores = nodamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_ES_nod_results <- run_test(mulea_amb_ES_nod)
# 
# 
# #+N NE
# mulea_N_NE_nod <- gsea(gmt = mulea_keggNE,
#                    element_names = nodN_ranks_mulea$names,
#                    element_scores = nodN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_NE_nod_results <- run_test(mulea_N_NE_nod)
# 
# 
# #--N NE
# mulea_amb_NE_nod <- gsea(gmt = mulea_keggNE,
#                    element_names = nodamb_ranks_mulea$names,
#                    element_scores = nodamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_NE_nod_results <- run_test(mulea_amb_NE_nod)
# 
# 
# 
# #bacteroid
# 
# #+N ES
# mulea_N_ES_bact <- gsea(gmt = mulea_keggES,
#                    element_names = bactN_ranks_mulea$names,
#                    element_scores = bactN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_ES_bact_results <- run_test(mulea_N_ES_bact)
# 
# #--N ES
# mulea_amb_ES_bact <- gsea(gmt = mulea_keggES,
#                    element_names = bactamb_ranks_mulea$names,
#                    element_scores = bactamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_ES_bact_results <- run_test(mulea_amb_ES_bact)
# 
# 
# #+N NE
# mulea_N_NE_bact <- gsea(gmt = mulea_keggNE,
#                    element_names = bactN_ranks_mulea$names,
#                    element_scores = bactN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_NE_bact_results <- run_test(mulea_N_NE_bact)
# 
# 
# #--N NE
# mulea_amb_NE_bact <- gsea(gmt = mulea_keggNE,
#                    element_names = bactamb_ranks_mulea$names,
#                    element_scores = bactamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_NE_bact_results <- run_test(mulea_amb_NE_bact)



# NOTE: decided to go with fitness ranking analysis exclusively; leaving this code in for documentation purposes and in case we need to give it a second look. This creates true rank-abundance curves based on the raw counts data rather than fitness ranking curves based off fitness ratios

# RAC <- function(x = ""){
#   x = as.vector(x)
#   x.ab = x[x > 0]
#   x.ab.ranked = x.ab[order(x.ab, decreasing = TRUE)]
#   return(x.ab.ranked)
# } #returns a rank-abundance dataset for a given site to be plotted
# 
# RACdata <- RACsubsetter %>%
#   group_by(group) %>%
#   summarise(across(starts_with("SM"), mean)) #averages each treatment together and produces a table listing mean counts
# 
# RACdata <- as.data.frame(RACdata)
# row.names(RACdata) <- RACdata[,1]
# RACdata <- RACdata[,-1] #cleans up dataframe so it can be unlisted and plotted
# 
# colnames(RACdata) <- substr(colnames(RACdata), 0, 9)
# RACnames <- grep("^SMa", colnames(RACdata))
# colnames(RACdata)[RACnames] <- substr((colnames(RACdata))[RACnames], 0, 7)
# trueRACnames <- grep("^SMc", colnames(RACdata)) 
# colnames(RACdata)[trueRACnames] <- gsub("\\s+$", "", colnames(RACdata)[trueRACnames]) #ensures column names are exactly the same as the ones in Nmetabolism for matching genes of interest
# 
# RACdata_Nmetabolism <- RACdata[, intersect(colnames(RACdata), Nmetabolism$V1)] #similar code from elsewhere wasn't working, so I asked chatGPT to suggest a new method and it gave me the intersect() syntax within this
# 
# RACdata_nodNE <- RACdata[, intersect(colnames(RACdata), colnames(nodNEfit))]
# RACdata_nodES <- RACdata[, intersect(colnames(RACdata), colnames(nodESfit))]
# 
# #RACs for whole genomes
# bactambRAC <- unlist(RACdata[1,])
# bactfertRAC <- unlist(RACdata[2,])
# nodambRAC <- unlist(RACdata[3,])
# nodfertRAC <- unlist(RACdata[4,])
# t0RAC <- unlist(RACdata[5,]) #converts rows to proper format for RAC analysis and plotting
# 
# RAC_bactamb <- RAC(bactambRAC)
# RAC_bactfert <- RAC(bactfertRAC)
# RAC_nodamb <- RAC(nodambRAC)
# RAC_nodfert <- RAC(nodfertRAC)
# RAC_t0 <- RAC(t0RAC)
# 
# #RACs for N metabolism genes
# Nmetab_bactambRAC <- unlist(RACdata_Nmetabolism[1,])
# Nmetab_bactfertRAC <- unlist(RACdata_Nmetabolism[2,])
# Nmetab_nodambRAC <- unlist(RACdata_Nmetabolism[3,])
# Nmetab_nodfertRAC <- unlist(RACdata_Nmetabolism[4,])
# Nmetab_t0RAC <- unlist(RACdata_Nmetabolism[5,])
# 
# RAC_Nmetab_bactamb <- RAC(Nmetab_bactambRAC)
# RAC_Nmetab_bactfert <- RAC(Nmetab_bactfertRAC)
# RAC_Nmetab_nodamb <- RAC(Nmetab_nodambRAC)
# RAC_Nmetab_nodfert <- RAC(Nmetab_nodfertRAC)
# RAC_Nmetab_t0 <- RAC(Nmetab_t0RAC)
# 
# finalRACdata_Nmetabolism <- as.data.frame(rbind(RAC_Nmetab_bactamb, RAC_Nmetab_bactfert, RAC_Nmetab_nodamb, RAC_Nmetab_nodfert, RAC_Nmetab_t0))
# colnames(finalRACdata_Nmetabolism) <- 1:29
# 
# #RACs for nodulation ES and NE genes
# 
# #NE
# nodNE_bactambRAC <- unlist(RACdata_nodNE[1,])
# nodNE_bactfertRAC <- unlist(RACdata_nodNE[2,])
# nodNE_nodambRAC <- unlist(RACdata_nodNE[3,])
# nodNE_nodfertRAC <- unlist(RACdata_nodNE[4,])
# nodNE_t0RAC <- unlist(RACdata_nodNE[5,])
# 
# RAC_nodNE_bactamb <- RAC(nodNE_bactambRAC)
# RAC_nodNE_bactfert <- RAC(nodNE_bactfertRAC)
# RAC_nodNE_nodamb <- RAC(nodNE_nodambRAC)
# RAC_nodNE_nodfert <- RAC(nodNE_nodfertRAC)
# RAC_nodNE_t0 <- RAC(nodNE_t0RAC)
# 
# finalRACdata_nodNE <- as.data.frame(rbind(RAC_nodNE_bactamb, RAC_nodNE_bactfert, RAC_nodNE_nodamb, RAC_nodNE_nodfert, RAC_nodNE_t0))
# colnames(finalRACdata_nodNE) <- 1:4145
# 
# #ES
# nodES_bactambRAC <- unlist(RACdata_nodES[1,])
# nodES_bactfertRAC <- unlist(RACdata_nodES[2,])
# nodES_nodambRAC <- unlist(RACdata_nodES[3,])
# nodES_nodfertRAC <- unlist(RACdata_nodES[4,])
# nodES_t0RAC <- unlist(RACdata_nodES[5,])
# 
# RAC_nodES_bactamb <- RAC(nodES_bactambRAC)
# RAC_nodES_bactfert <- RAC(nodES_bactfertRAC)
# RAC_nodES_nodamb <- RAC(nodES_nodambRAC)
# RAC_nodES_nodfert <- RAC(nodES_nodfertRAC)
# RAC_nodES_t0 <- RAC(nodES_t0RAC)
# 
# finalRACdata_nodES <- as.data.frame(rbind(RAC_nodES_bactamb, RAC_nodES_bactfert, RAC_nodES_nodamb, RAC_nodES_nodfert, RAC_nodES_t0))
# colnames(finalRACdata_nodES) <- 1:832
# 
# #Kolmogorov-Smirnov tests to determine if rank-abundance curves are significantly different between treatments; WHOLE-GENOME SET
# 
# ks_bacteroid <- ks.test(RAC_bactamb, RAC_bactfert, exact = TRUE) #bacteroid treatment, -N vs +N
# ks_nodule <- ks.test(RAC_nodamb, RAC_nodfert, exact = TRUE) #undiff nodule treatment, -N vs +N
# 
# ks_amb_compartment <- ks.test(RAC_nodamb, RAC_bactamb, exact = TRUE) #Bacteroid  vs undiff nodule at -N
# ks_fert_compartment <- ks.test(RAC_bactfert, RAC_nodfert, exact = TRUE) #B vs undiff n at +N
# 
# #K-S N METABOLISM
# 
# ks_bacteroid_Nmetab <- ks.test(RAC_Nmetab_bactamb, RAC_Nmetab_bactfert, exact = TRUE) 
# ks_nodule_Nmetab <- ks.test(RAC_Nmetab_nodamb, RAC_Nmetab_nodfert, exact = TRUE)
# 
# ks_amb_compartment_Nmetab <- ks.test(RAC_Nmetab_nodamb, RAC_Nmetab_bactamb, exact = TRUE)
# ks_fert_compartment_Nmetab <- ks.test(RAC_Nmetab_bactfert, RAC_Nmetab_nodfert, exact = TRUE)
# 
# #K-S NODULATION NONESSENTIAL/ESSENTIAL
# 
# ks_bacteroid_nodNE <- ks.test(RAC_nodNE_bactamb, RAC_nodNE_bactfert, exact = TRUE) 
# ks_nodule_nodNE <- ks.test(RAC_nodNE_nodamb, RAC_nodNE_nodfert, exact = TRUE)
# 
# ks_amb_nodNE <- ks.test(RAC_nodNE_nodamb, RAC_nodES_bactamb, exact = TRUE)
# ks_fert_nodNE <- ks.test(RAC_nodNE_nodfert, RAC_nodNE_bactfert, exact = TRUE)
# 
# ks_bacteroid_nodES <- ks.test(RAC_nodES_bactamb, RAC_nodES_bactfert, exact = TRUE)
# ks_nodule_nodES <- ks.test(RAC_nodES_nodamb, RAC_nodES_nodfert, exact = TRUE)
# 
# ks_amb_nodES <- ks.test(RAC_nodES_nodamb, RAC_nodES_bactamb, exact = TRUE)
# ks_fert_nodES <- ks.test(RAC_nodES_nodfert, RAC_nodES_bactfert, exact = TRUE)

# # simple curve plots of the RACs
# 
# all_RACs <- ls(pattern = "^RAC_") #make a list with all 20 RACs
# 
# for (i in 1:length(all_RACs)) {
#   plot.new()
#   ranks <- as.vector(seq(1, length(get(all_RACs[i]))))
#   opar <- par(no.readonly = TRUE)
#   par(mar = c(5.1, 5.1, 4.1, 2.1))
#   plot(ranks, log(get(all_RACs[i])), type = 'p', axes = F,
#        xlab = "Rank in abundance", ylab = "Abundance",
#        las = 1, cex.lab = 1.4, cex.axis = 1.25)
#   
#   box()
#   axis(side = 1, labels = T, cex.axis = 1.25)
#   axis(side = 2, las = 1, cex.axis = 1.25,
#        labels = c(1, 100, 10000, 100000, 1000000), at = log(c(1, 100, 10000, 100000, 1000000)))
#   
#   mtext(all_RACs[i], side = 3, line = 1, cex = 1.5)
# } #This for loop calls the above plot code on all 20 RAC names listed within all_RACs, producing 20 rank-abundance curves
# 
# #ggplot violin plots of RAC data
# 
# for (i in 1:length(all_RACs)) {
#   
#   p <- ggplot(data.frame(x = 1:length(get(all_RACs[[i]])), 
#                           y = get(all_RACs[[i]])), 
#               aes(x = "", y = y)) +
#     geom_violin(fill = "gray", alpha = 0.8) + #violin plot
#     geom_jitter(color = "black", size = 1.5, alpha = 0.4) + #point layer
#     xlab("") +
#     ylab("Abundance") +
#     ggtitle(all_RACs[[i]]) + #title by variable name
#     theme_classic() #need to tweak theme to make it look better/cleaner
#   print(p)
# }

#example code for plotting RACs together on the same axis; the ranks need some fixing
# 
# finalRACdata_complete <- as.data.frame(rbind(RAC_bactamb, RAC_bactfert, RAC_nodamb, RAC_nodfert, RAC_t0))
# colnames(finalRACdata_complete) <- 1:5175
# finalRACdata_complete$treatment <- row.names(finalRACdata_complete)
# 
# finalRACdata_complete <- pivot_longer(finalRACdata_complete, cols = colnames(finalRACdata_complete)[1:5175])
# 
# combinedRAC_complete <- ggplot(finalRACdata_complete, aes(x = as.numeric(as.character(name)), y = log10(value), group = treatment, color = treatment, fill = treatment)) +
#   geom_line()
# 
# combinedRAC_complete


# #CMH TESTS organizing data
# 
# CMHstrata <- potlabels[-c(14:18)]
# CMHpots <- c("_nf", "_nf", "_nf", "_na", "_na", "_na", "_na", "_na", "_bf", "_bf", "_bf", "_ba", "_ba")
# CMHstratanames <- paste(CMHstrata, CMHpots, sep = "") #sets of ids to identify strata and individual dataset names
# CMH_env <- new.env() #new env to store CMH tables
# for (df_name in COGnames) {
#   df <- get(df_name)
#   essential_pos <- vector("integer", length = 13)
#   essential_neg <- vector("integer", length = 13)
#   essential_neu <- vector("integer", length = 13)
#   N_pos <- vector("integer", length = 13)
#   N_neg <- vector("integer", length = 13)
#   N_neu <- vector("integer", length = 13) #empty lists to store results
# 
#   for (i in 2:14) {
#     essential_pos[i] <- sum(df$essentiality == "essential" & df[[i]] == 1)
#     essential_neg[i] <- sum(df$essentiality == "essential" & df[[i]] == -1)
#     essential_neu[i] <- sum(df$essentiality == "essential" & df[[i]] == 0)
# 
#     N_pos[i] <- sum(df$essentiality == "N" & df[[i]] == 1)
#     N_neg[i] <- sum(df$essentiality == "N" & df[[i]] == -1)
#     N_neu[i] <- sum(df$essentiality == "N" & df[[i]] == 0) #count pos, neu, neg for each essentiality category
#   }
#     df_output <- data.frame(
#     essential_pos = essential_pos,
#     essential_neg = essential_neg,
#     essential_neu = essential_neu,
#     N_pos = N_pos,
#     N_neg = N_neg,
#     N_neu = N_neu
#   ) %>%
#       t() %>%
#       .[, -1] #transpose and delete column of zeroes (don't know why for(i in 2:14) doesn't get rid of the zero col?)
#     #creates output df with 13 data columns and 6 rows for categorical totals
#   colnames(df_output) <- CMHstratanames
#   output_name <- paste0("CMH_", df_name)
#   assign(output_name, df_output, envir = CMH_env)
# } #names CMH_COG_X to CMH environment
# 
# 
# #make tables for CMH tests
# 
# output_dfs <- list() # empty list to store finished tables
# for (df_name in ls(envir = CMH_env, pattern = "CMH_COG_")) {
#   df <- get(df_name, envir = CMH_env) #iterate through all COG dfs in CMH_env
#     cog_id <- substr(df_name, nchar(df_name) - 4, nchar(df_name)) #retrieve cog ID from df name
# 
#   row_names <- c("essential_pos", "essential_neg", "essential_neu", "N_pos", "N_neg", "N_neu") #input df row names
# 
#   for (col_name in colnames(df)) {
#     positive_table <- matrix(
#       c(df[row_names[1], col_name], df[row_names[3], col_name], df[row_names[4], col_name], df[row_names[6], col_name]),
#       nrow = 2,
#       dimnames = list(c("essential", "N"), c("positive", "neutral"))
#     ) #create positive contingency table
#     positive_df <- data.frame(essentiality = c("essential", "N"),
#                               positive = positive_table[1, ],
#                               neutral = positive_table[2, ])
#     output_name_positive <- paste0("CMH_", cog_id, "_", col_name, "_positive")
#     output_dfs[[output_name_positive]] <- positive_df #grabs data for positive tables and adds to corresponding empty table
# 
#     negative_table <- matrix(
#       c(df[row_names[2], col_name], df[row_names[3], col_name], df[row_names[5], col_name], df[row_names[6], col_name]),
#       nrow = 2,
#       dimnames = list(c("essential", "N"), c("negative", "neutral"))
#     )
#     negative_df <- data.frame(essentiality = c("essential", "N"),
#                               negative = negative_table[1, ],
#                               neutral = negative_table[2, ])
#     output_name_negative <- paste0("CMH_", cog_id, "_", col_name, "_negative")
#     output_dfs[[output_name_negative]] <- negative_df #ditto for the negative tables
#   }
# }
# 
# for (df_name in names(output_dfs)) {
#   df <- output_dfs[[df_name]]
#     row.names(df) <- df$essentiality
#     df <- df[, -1]
#     output_dfs[[df_name]] <- df
# } #clean up outputs to replace row names with third names column and delete, leaving only 2x2 table
# list2env(output_dfs, envir = CMH_env) #store in CMH_env
# 
# partitioned_CMHenv <- new.env() #new env to store subsets
# CMH_partitions <- ls(CMH_env) #list out all the objects we're working on
# CMH_cogs <- substring(CMH_partitions, 9, 9) #extract COG index for each item
# CMH_unique_cogs <- unique(CMH_cogs) #get list of unique COGs
# 
# for(cog in CMH_unique_cogs) {
#   unique_cog <- CMH_partitions[CMH_cogs == cog] #iterate through unique COG list and pull out all objects in CMH_cogs which match the current unique COG in the list
#   partition_name <- paste0("CMH_", cog, "_env") #name output env according to COG at hand
#   new_partition_env <- new.env() #create env
#   for(cogname in unique_cog){
#     new_partition_env[[cogname]] <- CMH_env[[cogname]] #puts objects of that cogname from CMH_env into new env
#   }
#   partitioned_CMHenv[[partition_name]] <- new_partition_env #assigns env at hand to master list of partitioned envs, bearing the partition_name at hand in this iteration
# }
# 
# for(env_name in ls(partitioned_CMHenv)) {
#   partition <- partitioned_CMHenv[[env_name]]
#   cog_names <- ls(partition)
#   removed <- cog_names[nchar(cog_names) == 9]
#   rm(list = removed, envir = partition)
# } #remove CMH envs containing raw data from building the tables
# 
# 
# 
# sample_names <- unique(substr(ls(partitioned_CMHenv)[[1]], 11, 14)) #get unique 4-char id from each site name
# positive_CMH_results <- list()
# negative_CMH_results <- list() #separate lists for pos and neg results
# 
# 
# for (cog_group_name in ls(partitioned_CMHenv)) {
#   cog_group_env <- partitioned_CMHenv[[cog_group_name]]  #get the listed data from each COG group in the env
#   
#   positive_array <- array(dim = c(2, 2, 13, length(sample_names)))
#   negative_array <- array(dim = c(2, 2, 13, length(sample_names))) #separate arrays for pos and neg comparisons
# 
#   for (table_name in ls(cog_group_env)) { #inner loop goes through each table in the current COG group
#     unique_id <- substr(table_name, 11, 14)
#     table_idx <- which(sample_names == unique_id) #get the index of the object from sample_names to keep track of where the id came from
#     
#   target_array <- if (grepl("positive", table_name)) {
#     positive_array
#   } else {
#     negative_array
#   } #separate based on pos/neg comparison
#     
#     target_array[, , , table_idx] <- cog_group_env[[table_name]] #assign tabel at hand to correct array
#   }
# 
#   positive_CMH_result <- mantelhaen.test(positive_array)
#   negative_CMH_result <- mantelhaen.test(negative_array) #run CMH tests
# 
#   positive_CMH_results[[paste0("CMH_", cog_group_name, "_positive")]] <- positive_CMH_result
#   negative_CMH_results[[paste0("CMH_", cog_group_name, "_negative")]] <- negative_CMH_result #store results
# }
# 
# 



#commented code is for duplicating kegg ko ids to run functional analysis. I decided to use pathway ids only so this is deprecated 

# newtags_modified <- newtags #save duplicate in case something gets messed up while coding
# 
# for (i in 1:nrow(newtags_modified)) {
#   kegg_ko <- newtags_modified[i, "KEGG_ko"]
#   if (!is.na(kegg_ko) && grepl(",", kegg_ko)) {
#     kegg_ids <- unlist(strsplit(kegg_ko, ",")) #splits entries with multiple KEGG KOs by the comma separator
#     for (id in kegg_ids) {
#       new_row <- newtags_modified[i, ]
#       new_row["KEGG_ko"] <- trimws(id) #creates duplicate rows and adds new KEGG id
#       newtags_modified <- rbind(newtags_modified, new_row)
#     }
#     newtags_modified <- newtags_modified[-i, ] #gets rid of original KEGG id row with unsplit entries
#     i <- i - 1  #adjust the index to account for removed row
#   }
# }
# row.names(newtags_modified) <- NULL #fixes weird row names created by this procedure

#old contingency table code

# contingency_tables <- list() #creates empty list to store conting tables 
# 
# for (name in COGnames) {
#   df <- get(name)
#   treatment_cols <- c(19:21, 22:26, 27:29, 30:31)
#   treatment_names <- c("nod +N", "nod -N", "bact +N", "bact -N")
#   if (length(treatment_names) != length(treatment_cols)) {
#     treatment_names <- rep(treatment_names, length.out = length(treatment_cols))
#   }  #defines ranges to be summed together to pool each treatment for conting tables, and corrects length 
#   num_treatments <- length(treatment_cols)
#   contingency_table <- matrix(0, nrow = 3, ncol = num_treatments,
#                               dimnames = list(c("decreasing", "neutral", "increasing"), treatment_names)) #creates table objects
#   
#   for (i in 1:num_treatments) {
#     treatment_col <- df[[treatment_cols[i]]]
#     counts <- table(factor(treatment_col, levels = c(-1, 0, 1)))
#     contingency_table[, i] <- counts
#   } #adds count labels to table objects
#   contingency_tables[[name]] <- contingency_table
# }
# 
# for (name in names(contingency_tables)) {
#   table_name <- paste0(name, "_table")
#   assign(table_name, unlist(contingency_tables[[name]]))
# } #names tables according to the COG they represent
# 
# all_dfs <- ls(globalenv())
# COGtables <- grep("^COG_.*_table$", ls(), value = TRUE)
# 
# for (i in seq_along(COGtables)) {
#   df_name <- COGtables[i]
#   df <- get(df_name)
#   column_ranges <- list(c(1:3), c(4:8), c(9:11), c(12:13))
#   merged_df <- data.frame(matrix(0, nrow = nrow(df), ncol = length(column_ranges)))
#   rownames(merged_df) <- rownames(df)
#   
#   for (j in seq_along(column_ranges)) {
#     columns <- column_ranges[[j]]
#     merged_df[, j] <- rowSums(df[, columns, drop = FALSE])
#   }
#   assign(df_name, merged_df, envir = globalenv())
#} #tabulates contingency data for each COG table


# some old KEGG code here that I don't want to get rid of in case I want to reuse parts of it

# create subsets by essentiality for symbiosis
# KEGGfitmetadata_ES <- subset(KEGGfitmetadata, essentiality == "essential")
# KEGGfitmetadata_NE <- subset(KEGGfitmetadata, essentiality == "N")
# KEGGfitmetadata_ES <- KEGGfitmetadata_ES[, -c(3)]
# KEGGfitmetadata_NE <- KEGGfitmetadata_NE[, -c(3)] 
# 
# KEGGfitmetadata_ES$KEGG_Pathway <- trimws(KEGGfitmetadata_ES$KEGG_Pathway)
# KEGGfitmetadata_NE$KEGG_Pathway <- trimws(KEGGfitmetadata_NE$KEGG_Pathway)
# KEGGfitmetadata_ES$KEGG_Pathway <- as.character(KEGGfitmetadata_ES$KEGG_Pathway)
# KEGGfitmetadata_NE$KEGG_Pathway <- as.character(KEGGfitmetadata_NE$KEGG_Pathway) #apparently have to do this to get strsplit() to work
# 
# #list names of unique pathway ids for making contingency tables downstream
# KEGGtablenames_ES <- character() #create vector of contingency table names
# for (i in seq_len(nrow(KEGGfitmetadata_ES))) {
#   pathway_ids <- unlist(strsplit(KEGGfitmetadata_ES[["KEGG_Pathway"]][i], ",")) #unlist current cell in KEGG_Pathway by , separator
#   for (pathway_id in pathway_ids) {
#     pathway_id <- trimws(pathway_id)
#     if (grepl("^ko\\d{5}$", pathway_id) && !pathway_id %in% KEGGtablenames_ES) {
#       KEGGtablenames_ES <- c(KEGGtablenames_ES, pathway_id) #if KEGG id starts with ko and is followed by 5 numbers, and this particular one isn't already added to KEGGtablenames, then add it
#     }
#   }
# }
# 
# KEGGtablenames_NE <- character() 
# for (i in seq_len(nrow(KEGGfitmetadata_NE))) {
#   pathway_ids <- unlist(strsplit(KEGGfitmetadata_NE[["KEGG_Pathway"]][i], ","))
#   for (pathway_id in pathway_ids) {
#     pathway_id <- trimws(pathway_id) 
#     if (grepl("^ko\\d{5}$", pathway_id) && !pathway_id %in% KEGGtablenames_NE) {
#       KEGGtablenames_NE <- c(KEGGtablenames_NE, pathway_id)
#     }
#   }
# }
# 
# expanded_rows_ES <- data.frame(KEGG_Pathway = character(), stringsAsFactors = FALSE)
# expanded_rows_NE <- data.frame(KEGG_Pathway = character(), stringsAsFactors = FALSE) #make aux dfs to work with inside the loops
# 
# 
# for (i in seq_len(nrow(KEGGfitmetadata_ES))) {
#   pathway_ids <- unlist(strsplit(as.character(KEGGfitmetadata_ES[i, "KEGG_Pathway"]), ",")) #split pathway id cells
#   pathway_ids <- pathway_ids[!grepl("^map\\d{5}$", pathway_ids)] #get rid of map ids
#   
#   for (pathway_id in pathway_ids) {
#     new_row <- KEGGfitmetadata_ES[i, ]
#     new_row[["KEGG_Pathway"]] <- trimws(pathway_id) #duplicate rows containing multiple pathway ids
#     expanded_rows_ES <- rbind(expanded_rows_ES, new_row) #add duplicate row to recipient df
#   }
# } #expand and duplicate by pathway id as in COG analysis
# 
# for (i in seq_len(nrow(KEGGfitmetadata_NE))) {
#   pathway_ids <- unlist(strsplit(as.character(KEGGfitmetadata_NE[i, "KEGG_Pathway"]), ","))
#   pathway_ids <- pathway_ids[!grepl("^map\\d{5}$", pathway_ids)]
#   
#   for (pathway_id in pathway_ids) {
#     new_row <- KEGGfitmetadata_NE[i, ]
#     new_row[["KEGG_Pathway"]] <- trimws(pathway_id)
#     expanded_rows_NE <- rbind(expanded_rows_NE, new_row)
#   }
# }  #expand and duplicate by pathway id as in COG analysis
# 
# KEGGfitmetadata_ES <- expanded_rows_ES[complete.cases(expanded_rows_ES), , drop = FALSE]
# KEGGfitmetadata_NE <- expanded_rows_NE[complete.cases(expanded_rows_NE), , drop = FALSE] #removes rows with NAs

# #old turnover stuff--going to do Whitaker's
# 
# library(betapart)
# 
# # fitness values can't be directly analyzed using bray-curtis or jaccard
# 
# fit_turnoverdat <- ifelse(completefit <= -1, -1, ifelse(completefit >= 1, 1, 0)) #replace fitness values with 1, 0, or -1 depending on value (pos/neu/neg)
# fit_turnoverdat <- as.data.frame(fit_turnoverdat[1:(nrow(fit_turnoverdat) - 5),])
# fit_turnoverdat <- cbind(group = c("fert", "fert", "fert", "amb", "amb", "amb", "amb", "amb", "fert", "fert", "fert", "amb", "amb"), fit_turnoverdat)
# 
# shared_cols_ES <- intersect(names(as.data.frame(nodESfit)), names(fit_turnoverdat))
# shared_cols_NE <- intersect(names(as.data.frame(nodNEfit)), names(fit_turnoverdat)) #extract cols from ES and NE which are found in input data
# fit_turnover_ES <- fit_turnoverdat[, c("group", shared_cols_ES)]
# fit_turnover_NE <- fit_turnoverdat[, c("group", shared_cols_NE)] #subsets based on intersection
# 
# 
# fert_zero_counts_ES <- rowSums(fit_turnover_ES[fit_turnover_ES$group == "fert", -1] == 0)
# amb_zero_counts_ES <- rowSums(fit_turnover_ES[fit_turnover_ES$group == "amb", -1] == 0)
# fert_minus_one_ones_ES <- apply(fit_turnover_ES[fit_turnover_ES$group == "fert", -1], 1, function(row) sum(row %in% c(-1, 1)))
# amb_minus_one_ones_ES <- apply(fit_turnover_ES[fit_turnover_ES$group == "amb", -1], 1, function(row) sum(row %in% c(-1, 1))) #calc # of each category for ES
# fert_zero_counts_NE <- rowSums(fit_turnover_NE[fit_turnover_NE$group == "fert", -1] == 0)
# amb_zero_counts_NE <- rowSums(fit_turnover_NE[fit_turnover_NE$group == "amb", -1] == 0)
# fert_minus_one_ones_NE <- apply(fit_turnover_NE[fit_turnover_NE$group == "fert", -1], 1, function(row) sum(row %in% c(-1, 1)))
# amb_minus_one_ones_NE <- apply(fit_turnover_NE[fit_turnover_NE$group == "amb", -1], 1, function(row) sum(row %in% c(-1, 1))) # for NE
# 
# fertzeromean_ES <- mean(fert_zero_counts_ES)
# ambzeromean_ES <- mean(amb_zero_counts_ES)
# fertonesmean_ES <- mean(fert_minus_one_ones_ES)
# ambonesmean_ES <- mean(amb_minus_one_ones_ES)
# fertzeromean_NE <- mean(fert_zero_counts_NE)
# ambzeromean_NE <- mean(amb_zero_counts_NE)
# fertonesmean_NE <- mean(fert_minus_one_ones_NE)
# ambonesmean_NE <- mean(amb_minus_one_ones_NE) #mean counts
# 
# contingency_selection_ES <- matrix(c(fertzeromean_ES, fertonesmean_ES,
#                                      ambzeromean_ES, ambonesmean_ES),
#                                    nrow = 2, byrow = TRUE)
# contingency_selection_NE <- matrix(c(fertzeromean_NE, fertonesmean_NE,
#                                      ambzeromean_NE, ambonesmean_NE),
#                                    nrow = 2, byrow = TRUE) #make 2x2 tables comparing pos/neu and neu/neg
# 
# dimnames(contingency_selection_ES) <- list(c("fert", "amb"), c("0", "-1/1"))
# dimnames(contingency_selection_NE) <- list(c("fert", "amb"), c("0", "-1/1")) #assign names
# 
# test_underselection_ES <- chisq.test(contingency_selection_ES)
# test_underselection_NE <- chisq.test(contingency_selection_NE) #chisq tests of significant turnover by N treatment
#
# 
# fit_turnover_forjaccard <- as.data.frame(ifelse(fit_turnoverdat <= 0, 0, 1))
# 
# turnover_permanova <- adonis2(fit_turnover_forjaccard ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = fit_turnover_forjaccard, permutations = 9999, method="jaccard")
# 
# turnover_permanova

#omnibus fgsea tests; no significant results when averaging across treatments

#make pathways file

# COGlist_omnibus <- lapply(unique(COGmatrices$COG), function(currCOG) {
#   COG_X_omnibus <- COGmatrices %>%
#     filter(COG == currCOG)
# 
#   return(COG_X_omnibus)
# })
# 
# for (i in seq_along(COGlist_omnibus)) {
#   currCOG <- unique(COGlist_omnibus[[i]]$COG)
#   assign(paste0("COG_", currCOG, "_omnibus"), COGlist_omnibus[[i]])
# }
# 
# 
# genesetsCOG_omnibus <- lapply(seq_along(COGlist_omnibus), function(i) {
#   df <- COGlist_omnibus[[i]]
#   first_col <- as.character(df[[1]])
#   vector_name <- paste0("set", unique(df[[4]]))
#   names(first_col) <- NULL
#   names <- setNames(list(first_col), vector_name)
#   return(names)
# })
# genesetsCOG_omnibus <- unlist(genesetsCOG_omnibus, recursive = FALSE)
# 
# 
# writeGmtPathways(genesetsCOG_omnibus, tempfile("COGsets_omnibus", fileext = ".gmt"))
# 
# 
# pathways_omnibus <- gmtPathways("COGsets_omnibus.gmt")
# 
# #make rankings file
# 
# tlike_data_omnibus <- data.frame(tval = apply(tlike_data_meaned, 1, mean))
# 
# tlike_meaned_omnibus <- unlist(tlike_data_omnibus[,1])
# 
# names(tlike_meaned_omnibus) <- rownames(tlike_data_omnibus)
# 
# tlike_omnibus_ranked <- rankfit(tlike_meaned_omnibus)
# 
# tlike_omnibus_ranked <- tlike_omnibus_ranked[order(-tlike_omnibus_ranked$x),,drop=FALSE]
# 
# write.table(tlike_omnibus_ranked, file = "C:/Users/User/Desktop/omnibus_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE)
# 
# omnibus_ranks <- read.table("C:/Users/User/Desktop/omnibus_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
# 
# omnibus_ranks_final <- as.numeric(unlist(omnibus_ranks$x))
# names(omnibus_ranks_final) <- rownames(omnibus_ranks)
# 
# #run fgsea
# 
# fgsea_omnibus_cog <- fgsea(pathways_omnibus, omnibus_ranks_final, minSize = 1, maxSize = 1100)


#old code for extracting gene-level info from fgsea--deprecated because it didn't actually make sense

# #extract gene-level info from significant sets for both fgsea analyses
# 
# library(tidyr) #get unnest function
# 
# all_fgsea_cog <- ls(pattern = "fgsea", envir = globalenv()) #find all fgsea results
# 
# #function which extracts necessary info from each result set and builds df
# process_fgsea_results <- function(fgsea_results, uniqueID) {
#   unnested <- unnest(fgsea_results, leadingEdge) #get leading edge list from each row
# 
#   pathway <- unnested$pathway
#   gene_names <- unnested$leadingEdge
#   n_genes <- nrow(unnested) #get the pathway and gene info
#   
#   enrichment_scores <- rep(fgsea_results$NES, times = n_genes)
#   padj_values <- rep(fgsea_results$padj, times = n_genes) #adds padj, NES score for gene set to each gene
#   
#   result_df <- data.frame(
#     pathway = pathway,
#     gene_name = gene_names,
#     normed_ES_score = enrichment_scores,
#     padj = padj_values
#   ) #df to store results
#   
#   result_df$uniqueID <- uniqueID
#   return(result_df)
# }
# 
# output_data <- list() #store fgsea results that pass the tests here, so that they can be run through process_fgsea_results
# 
# for (fgsea_var in all_fgsea_cog) {
#   fgsea_object <- get(fgsea_var, envir = globalenv())
#   
#   fgsea_filtered <- subset(fgsea_object, padj <= 0.2) #get rid of nonsignificant sets
#   
#   # Extract the uniqueID from the fgsea_var using the pattern described
#   uniqueID <- sub(".*_(.+_.+_.+)", "\\1", fgsea_var) #gets rid of unnecessary info in each fgsea obj name; ChatGPT helped write this sub()
#   
#   if (nrow(fgsea_filtered) > 0) {
#     output_data[[fgsea_var]] <- process_fgsea_results(fgsea_filtered, uniqueID) #if there are significant results after filtering, process with function above
#   }
# }
# 
# result_df <- do.call(rbind, output_data)
# genelevelstats <- new.env() #combine results and create a new env to store them in
# 
# for (fgsea_var in all_fgsea_cog) {
#   uniqueID <- sub(".*_(.+_.+_.+)", "\\1", fgsea_var)
#   result_title <- paste("genelevel_", uniqueID, sep = "")
#   genelevelstats[[result_title]] <- result_df[result_df$uniqueID == uniqueID, ]
# } #title and store each result df in genelevelstats
# 
# for (result_title in ls(genelevelstats)) {
#   new_title <- gsub("__", "_", result_title)  
#   new_title <- gsub("_ctamb", "_bactamb", new_title)  
#   new_title <- gsub("_odamb", "_nodamb", new_title)  #fixes some naming oddities resulting from applying the same string manips to strings of diff lengths
#   
#   if (new_title != result_title) {
#     assign(new_title, genelevelstats[[result_title]], envir = genelevelstats)
#     rm(list = result_title, envir = genelevelstats)  #rename and remove original object if necessary
#   }
# }
# 
# #deprecated code for gene-level tables; I misremembered the plan for this and want to keep the code for later adaptation just in case
# 
# groups <- list(
#   group1 = 1:3,
#   group2 = 4:8,
#   group3 = 9:11,
#   group4 = 12:13
# ) #define col ranges
# completefit <- as_tibble(completefit) #convert to tibble for easier manipulation
# grouped_data <- list() #store results
# 
# for (group_name in names(groups)) {
#   rows_to_mean <- groups[[group_name]]
#   grouped_data[[group_name]] <- completefit[rows_to_mean, ] %>%
#     summarise(across(everything(), mean))
# } #mean fitness for each treatment/compartment group
# mean_completefit <- do.call(bind_rows, grouped_data) #mean df
# mean_completefit <- as.data.frame(mean_completefit) #convert back to df
# row.names(mean_completefit) <- c("Nod +N", "Nod -N", "Bact +N", "Bact -N")
# 
# #Make contingency tables for each gene
# 
# genelevel_tables <- new.env() #new env to prevent global env clutter
# 
# for (col_name in colnames(mean_completefit)) {
#   gene_data <- mean_completefit[[col_name]]
#   contingency_table <- matrix(gene_data, nrow = 2, byrow = TRUE,
#                               dimnames = list(c("Nod", "Bact"), c("+N", "-N"))) #build 2x2 tables of fitness values for each gene across the four categories
#   
#   table_name <- paste0(col_name, "_conting")
#   assign(table_name, contingency_table, envir = genelevel_tables)
# } 
# 
# table_names <- ls(envir = genelevel_tables) #store output in list for later use
# 
# #chi sq tests and fdr adjustment
# 
# chi_squared_results <- list()
# for (table_name in table_names) {
#   contingency_table <- get(table_name, envir = genelevel_tables) #retrieve the table object from the indexed name in the input list
#     chi_squared_result <- chisq.test(contingency_table)
#     chi_squared_results[[table_name]] <- chi_squared_result #perform test and store result
# }
# 
# p_values_genelevel <- sapply(chi_squared_results, function(result) result$p.value)
# adjusted_p_values_genelevel <- p.adjust(p_values_genelevel, method = "fdr") #retrieve pvals and perform fdr adjustment
# 
# significant_tables <- table_names[adjusted_p_values_genelevel <= 0.2] #filter for significant results
# significant_tables
#
# #whole-genome fgsea tests
# 
# pathways_complete <- gmtPathways("COGsets_omnibus.gmt")
# 
# fgsea_nodN_complete <- fgsea(pathways_complete, nodN_ranks, minSize = 1, maxSize = 1200)
# fgsea_nodamb_complete <- fgsea(pathways_complete, nodamb_ranks, minSize = 1, maxSize = 1200)
# fgsea_bactN_complete <- fgsea(pathways_complete, bactN_ranks, minSize = 1, maxSize = 1200)
# fgsea_bactamb_complete <- fgsea(pathways_complete, bactamb_ranks, minSize = 1, maxSize = 1200)
#
#notably, no significant results when looking at whole genome without partitioning

# #gene-level type iii anova analysis
# 
# 
# ANOVAcomplete <- COGcomplete
# 
# ANOVAcomplete <- ANOVAcomplete[, -c(32:36)] #remove t0
# 
# ANOVAfitness <- ANOVAcomplete[, c(1, 19:31)]
# 
# anovastrata <- potlabels[-c(14:18)]
# 
# rownames(ANOVAfitness) <- ANOVAfitness$locus_tag
# 
# ANOVAfitness <- t(ANOVAfitness[, -c(1)])
# 
# ANOVAfitness <- data.frame(Ntreatment = c(rep("fertilized",3), rep("ambient",5),rep("fertilized", 3), rep("ambient", 2)), compartment = c(rep("nodule",8), rep("bacteroid",5)), strata = anovastrata, ANOVAfitness)
# 
# 
# anovafit_results <- new.env()
# 
# for (i in 4:ncol(ANOVAfitness)) { #start here to avoid metadata columns
#   col_name <- colnames(ANOVAfitness)[i]
#   
#   formula <- as.formula(paste(col_name, "~ Ntreatment/compartment")) #anova formula
# 
#   anova_result <- Anova(lm(formula, data = ANOVAfitness), type = 'III') #runs anova
#   
#   assign(col_name, anova_result, envir = anovafit_results) #stores in results env
# }
# 
# 
# anovafit_significant <- new.env() 
# 
# for (obj_name in ls(anovafit_results)) {
#   result <- anovafit_results[[obj_name]] #goes through and picks out significant results
#   
#   if (any(result$"Pr(>F)"[1:3] < 0.05)) {
#     assign(obj_name, result, envir = anovafit_significant)
#   }
# }
# 
# anovafit_significant_qval <- new.env() #store results for fdr adjustment
# 
# all_p_values <- numeric()
# all_q_values <- numeric() #more storage
# 
# for (obj_name in ls(anovafit_significant)) {
#   result <- anovafit_significant[[obj_name]]
#   
#   p_values <- result$"Pr(>F)"[1:3]
#   
#   all_p_values <- c(all_p_values, p_values) #gather all the pvals from each listed results object
# }
# 
# all_q_values <- p.adjust(all_p_values, method = "fdr") #adjusts all at once
# split_q_values <- split(all_q_values, rep(seq_along(anovafit_significant), each = 3)) #each input df contributed 3 pvals, so qvals can be doled out in groups of 3
# 
# for (obj_name in ls(anovafit_significant)) {
#   result <- anovafit_significant[[obj_name]]
#   
#   q_values <- split_q_values[[obj_name]]
#   result$qval <- c(q_values, NA) #assigns results and adds an NA for the empty last cell
#   
#   assign(obj_name, result, envir = anovafit_significant_qval) #store results
# }
# 
# # Check the first few objects in anovafit_significant_qval
# head(ls(anovafit_significant_qval)) #NOTE: I never solved the issue of the qval results storing as NAs, and we decided not to use this, so it is interred here



```
