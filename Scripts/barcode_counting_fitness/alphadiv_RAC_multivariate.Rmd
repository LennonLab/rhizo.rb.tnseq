---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r Chunk 1: Data wrangling}


#FITNESS SCORE data--log2 ratios of endpoint/starting counts

fitdat = read.delim("C:/Users/User/Desktop/thesis_stuff/R_working/fitness_data/html/SmeliPlant/fit_logratios_clean.tab", row.names = 1)
#fitdat = read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/fit_logratios.tab", row.names = 1)
goodfitdat <- fitdat[, c("X21", "X22", "X24", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X35", "X37", "X40", "X41", "X42", "X43", "X44", "X45")]


#COUNTS DATA for analyses that can't use log ratio data for whatever reason (negative numbers in data, log scale, etc)

cleanrbdat = t(read.delim("C:/Users/User/Desktop/thesis_stuff/R_working/fitness_data/html/SmeliPlant/gene_counts_clean.tab", row.names = 1))
#cleanrbdat = t(read.delim("~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/gene_counts_clean.tab", row.names = 1))
goodcountdat <- subset(cleanrbdat, colnames(fitdat) %in% c("X21", "X22", "X24", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X35", "X37", "X40", "X41", "X42", "X43", "X44", "X45"))

#remove description from column names, leaving only locus id
newcountnames <- substr(colnames(goodcountdat), 0, 9)
colnames(goodcountdat) <- newcountnames 

#removes trailing characters from SMa ids
truecountnames <- grep("^SMa", colnames(goodcountdat))
colnames(goodcountdat)[truecountnames] <- substr(colnames(goodcountdat)[truecountnames], 0, 7) 

#ditto for SMc ids
finalcountnames <- grep("^SMc", colnames(goodcountdat))
colnames(goodcountdat)[finalcountnames] <- gsub("\\s+$", "", colnames(goodcountdat)[finalcountnames]) 
cleanrbdat <- as.data.frame(cleanrbdat)

#clean up and labels data by treatment/compartment
rownames(cleanrbdat) <- cleanrbdat$comb
cleanrbdat = t(cleanrbdat[,-c(1:4)])
metadata = as.data.frame(matrix(ncol=2,nrow=18))
metadata[,1] <-c(rep("nod",8),rep("bact",5),rep("start",5))
metadata[,2] <-c(rep("fertilized",3),rep("ambient",5),rep("fertilized",3),rep("ambient",2),rep("time0",5))
colnames(metadata) <- c("compartment","Ntreatment")  

#add numerical IDs to metadata df
goodqual_metadata <- metadata
row.names(goodqual_metadata) <- c("X21", "X22", "X24", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X35", "X37", "X40", "X41", "X42", "X43", "X44", "X45") 
potlabels <- c("1", "2", "4", "6", "7", "8", "9", "0", "1", "2", "5", "7", "0", "t0", "t0", "t0", "t0", "t0") 
#add abbreviated treatment/compartment id to the pot numbers
goodqual_metadata$newID <- potlabels 
finalmetadata <- subset(goodqual_metadata, row.names(goodqual_metadata) %in% c("X21", "X22", "X24", "X26", "X27", "X28", "X29", "X30", "X31", "X32", "X35", "X37", "X40")) #filters out t0


#various libraries needed for subsequent analyses
library(vegan)
library(ggplot2)
library(stringr)
library(tidyverse)
library(dplyr)
library(tidyr)
library(reshape2)
library(tibble)
library(ggdendro)
library(fgsea)
library(coin)
library(car)
require("psych")
```

```{r Chunk 2: Alpha diversity}



 #SHANNON DIVERSITY of lib

shannonfit <- numeric(nrow(goodcountdat))
for(j in 1:nrow(goodcountdat)) {
  shannonfit[j] <- vegan::diversity(goodcountdat[j,], index = "shannon")
}

shannonfit

#S&W EVENNESS of lib in each pot

#function calculating SMITH AND WILSON'S EVENNESS INDEX for the given site
Evar <- function(x) {
  x <- as.vector(x[x > 0])
  1 - (2/pi)*atan(var(log(x)))
} 

Evarfit <- numeric(nrow(goodcountdat))
for(j in 1:nrow(goodcountdat)) {
  Evarfit[j] <- Evar(goodcountdat[j,])
}

Evarfit 

#RICHNESS AND % FOUND

#function which returns the % OF SPECIES FOUND in each site
countzeros <- function(row) {
  numzeros <- sum(row == 0)
  percentzeros <- 100 - (numzeros / length(row) * 100)
  return(percentzeros)
} 

#calculates % found for each row (site)
percentfoundfit <- apply(goodcountdat, 1, countzeros) 
percentfoundfit

#function which returns OBSERVED SPECIES RICHNESS in a given site
S_obs <- function(x = ""){
  rowSums(x>0)*1
} 

#SPECIES (ie, gene/deletion mutant) RICHNESS
richnessfit <-  S_obs(goodcountdat)
richnessfit

#final collated dataframe of alpha diversity measures by pot
alphadiversitylib = as.data.frame(matrix(ncol=4,nrow=nrow(goodcountdat)))
colnames(alphadiversitylib) <- c('Shannon','SW_Evenness','percentFound','Richness')
rownames(alphadiversitylib) <- rownames(goodcountdat)
alphadiversitylib[,1] <- shannonfit
alphadiversitylib[,2] <- Evarfit
alphadiversitylib[,3] <- percentfoundfit
alphadiversitylib[,4] <- richnessfit
alphadiversitylib 
alphadivnames <- c("21 Nod +N", "22 Nod +N", "24 Nod +N", "26 Nod -N", "27 Nod -N", "28 Nod -N", "29 Nod -N", "30 Nod -N", "31 Bact +N", "32 Bact +N", "35 Bact +N", "37 Bact -N", "40 Bact -N", "t0 1", "t0 2", "t0 3", "t0 4", "t0 5")
rownames(alphadiversitylib) <- alphadivnames


#Statistical analysis of alphadiv data

alphadiversitylib$group <- c("nod +N", "nod +N", "nod +N", "nod ambient", "nod ambient", "nod ambient", "nod ambient", "nod ambient", "bact +N", "bact +N", "bact +N", "bact ambient", "bact ambient", "t0", "t0", "t0", "t0", "t0")

#grouped and meaned for reporting mean and SE
alphadiv_anova_data <- alphadiversitylib %>%
  group_by(group) %>%
  summarize(Mean_Shannon = mean(Shannon),
    SE_Shannon = sd(Shannon) / sqrt(n()),
    Mean_SWEvenness = mean(SW_Evenness),
    SE_Evenness = sd(SW_Evenness) / sqrt(n()),
    Mean_percentFound = mean(percentFound),
    SE_percentFound = sd(percentFound) / sqrt(n()),
    Mean_Richness = mean(Richness),
    SE_Richness = sd(Richness) / sqrt(n())
  ) 

alphadiv_onlyresponse <- head(alphadiversitylib, -5)
new_order <- c(ncol(alphadiversitylib), 1:(ncol(alphadiversitylib) - 1))
alphadiversitylib <- alphadiversitylib[, new_order]


#bartlett and shapiro tests, and Welch's anovas to test unbalanced alphadiv data

bartlett.test(Shannon ~ group, data = alphadiversitylib)
bartlett.test(SW_Evenness ~ group, data = alphadiversitylib)
bartlett.test(percentFound ~ group, data = alphadiversitylib)
bartlett.test(Richness ~ group, data = alphadiversitylib)

shapiro.test(alphadiversitylib$Shannon)
shapiro.test(alphadiversitylib$SW_Evenness)
shapiro.test(alphadiversitylib$percentFound)
shapiro.test(alphadiversitylib$Richness)

kruskal.test(Shannon ~ group, data = alphadiv_onlyresponse)
kruskal.test(SW_Evenness ~ group, data = alphadiv_onlyresponse)
kruskal.test(percentFound ~ group, data = alphadiv_onlyresponse)
kruskal.test(Richness ~ group, data = alphadiv_onlyresponse)

kruskal_pvals <- c(0.8807, 0.8698, 0.1438, 0.1438)

kruskal_q <- p.adjust(kruskal_pvals, method = "fdr")
```

```{r Chunk 3: Resemblance matrices}


#fitmetadata describes genes in detail--locus id, name, cog category, description, essentiality for nodulation, etc etc. 

fitmetadata <- read.csv("C:/Users/User/Desktop/analyze_Nfitness/smeliplant_neutral_cog_clean.csv")
#fitmetadata <- read.csv("~/Github/rhizo.rb.tnseq/Scripts/reciprocal_BLAST_essentiality/rbh_essentiality_supplies/smeliplant_neutral_cog_clean.csv")

#clean up empty col, remove description info from labels
fitmetadata <- fitmetadata[, -c(1)]
newnamesfitrel <- substr(row.names(goodfitdat), 0, 9) 
newnamesfitrel
row.names(goodfitdat) <- newnamesfitrel 

#remove trailing space and letter from SMa names
truenames <- grep("^SMa", row.names(goodfitdat)) 
row.names(goodfitdat)[truenames] <- substr(row.names(goodfitdat)[truenames], 0, 7) 

#remove trailing space from SMc names
truefitnames <- grep("^SMc", row.names(goodfitdat)) 
row.names(goodfitdat)[truefitnames] <- gsub("\\s+$", "", row.names(goodfitdat)[truefitnames])  

#fitness data subsetted into groups of interest
completefit <- merge(fitmetadata, goodfitdat, by.x = 1, by.y = 0)
nodESfit <- subset(completefit, essentiality=="essential")
nodNEfit <- subset(completefit, essentiality=="N") 

#to subset N metabolism genes, a blastKOALA annotation was conducted and N metabolism genes pulled from the KEGG reconstruction
nitrogengenes <- read.delim("C:/Users/User/Desktop/blastkoala_annotation_smeli.txt", header=FALSE)
#nitrogengenes <- read.delim("~/Github/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/blastkoala_annotation_smeli.txt", header=FALSE)

#same name-cleaning process as above; I wrote these before I knew about trimws()
nitrogengenes$V1 <- substr(nitrogengenes$V1, 7, 15)
Nnames <- grep("^SMa", nitrogengenes$V1)
nitrogengenes$V1[Nnames] <- substr((nitrogengenes$V1)[Nnames], 0, 7)
nitronames <- grep("^SMc", nitrogengenes$V1) 
nitrogengenes$V1[nitronames] <- gsub("\\s+$", "", nitrogengenes$V1[nitronames]) 

#these gene IDs are from Nmetabolismlist.txt, which is sourced from blastKOALA output
metabloci <- c("SMa0228", "SMc04028", "SMc04026", "SMa1250", "SM_b20986", "SMa1182", "SMc02150", "SMa0697", "SMc04083", "SMa0045", "SMc02613", "SMc00762", "SMc00948", "SMc01594", "SMc01973", "SMc02352", "SM_b20745", "SMa1276", "SMa1236", "SMa1233", "SM_b20436", "SMa0827", "SMa0825", "SMa0829", "SMa1273", "SMc04085", "SMa0585", "SMa0583", "SMa0581", "SM_b20985", "SM_b20984") 

#N metabolism fitness subset
Nmetabolism <- subset(nitrogengenes, V1 %in% metabloci)
Nmetabolismfit <- subset(completefit, completefit$locus_tag %in% Nmetabolism$V1) 

#save a version of the matrices which preserves metadata to be subsetted by COG in later analyses
COGnodES <- nodESfit
COGnodNE <- nodNEfit
COGcomplete <- completefit
COGNmetabolism <- Nmetabolismfit 

#KEGG df clones to preserve metadata for later
KEGGnodES <- nodESfit
KEGGnodNE <- nodNEfit
KEGGcomplete <- completefit
KEGGNmetabolism <- Nmetabolismfit 

#remove metadata from subsetted groups to get only the numerical data in the frame itself
nodESfit <- nodESfit[, -c(2:18)]
nodNEfit <- nodNEfit[, -c(2:18)]
completefit <- completefit[, -c(2:18)]
Nmetabolismfit <- Nmetabolismfit[, -c(2:18)] 

#update names and deletes extra row
row.names(nodESfit) <- nodESfit[,1]
nodESfit <- nodESfit[, -c(1)]
row.names(nodNEfit) <- nodNEfit[,1]
nodNEfit <- nodNEfit[, -c(1)]
row.names(completefit) <- completefit[,1]
completefit <- completefit[, -c(1)]
row.names(Nmetabolismfit) <- Nmetabolismfit[,1]
Nmetabolismfit <- Nmetabolismfit[, -c(1)] 

#need to be flipped to this orientation for cluster diagrams etc
nodESfit <- t(nodESfit)
nodNEfit <- t(nodNEfit)
completefit <- t(completefit)
Nmetabolismfit <- t(Nmetabolismfit) 

#relabel pots to include pot number and treatment/compartment info all in one
row.names(nodESfit) <- potlabels
row.names(nodNEfit) <- potlabels
row.names(completefit) <- potlabels
row.names(Nmetabolismfit) <- potlabels 

#resemblance matrices
dissim_nodES <- vegdist(nodESfit, method = "euclid", diag = FALSE)
dissim_nodNE <- vegdist(nodNEfit, method = "euclid", diag = FALSE)
dissim_complete <- vegdist(completefit, method = "euclid", diag = FALSE)
dissim_Nmetabolism <- vegdist(Nmetabolismfit, method = "euclid", diag = FALSE) 

#autoscaled matrices for kmo/bartlett tests (need to be scaled before making final cor matrices for tests)
scaled_nodES <- scale(nodESfit)
scaled_nodNE <- scale(nodNEfit)
scaled_complete <- scale(completefit)
scaled_Nmetabolism <-scale(Nmetabolismfit) 

#correlation matrices for downstream statistical analyses
cor_nodES <- cor(scaled_nodES)
cor_nodNE <- cor(scaled_nodNE)
cor_complete <- cor(scaled_complete)
cor_Nmetabolism <- cor(scaled_Nmetabolism) 

#scaled matrices without t0 for permanova, PCA, etc
finalscaled_nodES <- as.data.frame(scaled_nodES[1:(nrow(scaled_nodES) - 5),])
finalscaled_nodNE <- as.data.frame(scaled_nodNE[1:(nrow(scaled_nodNE) - 5),])
finalscaled_complete <- as.data.frame(scaled_complete[1:(nrow(scaled_complete) - 5),])
finalscaled_Nmetabolism <- as.data.frame(scaled_Nmetabolism[1:(nrow(scaled_Nmetabolism) - 5),]) 
```

```{r Chunk 4: unscaled PERMANOVAs}


#remove t0 from original, unscaled dfs
covar_nodES <- as.data.frame(nodESfit[1:(nrow(scaled_nodES) - 5),])
covar_nodNE <- as.data.frame(nodNEfit[1:(nrow(scaled_nodES) - 5),])
covar_complete <- as.data.frame(completefit[1:(nrow(scaled_nodES) - 5),])
covar_Nmetab <- as.data.frame(Nmetabolismfit[1:(nrow(scaled_nodES) - 5),]) 

#unscaled PERMANOVA with FDR adjustment
nodES_covar_permanova <- adonis2(covar_nodES ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = covar_nodES, permutations = 9999, method="euclidean")

nodNE_covar_permanova <- adonis2(covar_nodNE ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = covar_nodNE, permutations = 9999, method="euclidean")

complete_covar_permanova <- adonis2(covar_complete ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = covar_complete, permutations = 9999, method="euclidean")

Nmetab_covar_permanova <- adonis2(covar_Nmetab ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = covar_Nmetab, permutations = 9999,  method="euclidean")

nodES_covar_permanova
nodNE_covar_permanova
complete_covar_permanova
Nmetab_covar_permanova

covar_permanova_pvals <- c(complete_covar_permanova$`Pr(>F)`,  Nmetab_covar_permanova$`Pr(>F)`, nodES_covar_permanova$`Pr(>F)`, nodNE_covar_permanova$`Pr(>F)`)
covar_permanova_pvals <- na.omit(covar_permanova_pvals)

adjusted_covarpermanova_pvals <- p.adjust(covar_permanova_pvals, method = "fdr")
allcovar_permanova <- ls(pattern = "_covar_permanova$")


#make tables to individually report statistics for each pca plot
results_list <- list()

for (i in 1:length(allcovar_permanova)) {
  name <- allcovar_permanova[i]
  permanova_test <- get(name) #go through all the permanova names, store name and retrieve object from name
    permanova_df <- as.data.frame(permanova_test)
    stats_matrix <- permanova_df[1:3, 3:5] #convert to df to get relevant numbers
  
  start_idx <- (i - 1) * 3 + 1
  end_idx <- start_idx + 2
  q_values <- adjusted_covarpermanova_pvals[start_idx:end_idx] #get qvals from fdr list... had chatGPT help write the indexing 
  
  df <- as.data.frame(stats_matrix)
    rownames(df) <- c("finalmetadata$Ntreatment", "finalmetadata$newID", "finalmetadata$Ntreatment:finalmetadata$compartment")
    colnames(df) <- c("R2", "F_statistic", "p_value")
    df$q_value <- q_values
    new_name <- paste(name, "table", sep = "_")
  assign(new_name, df, envir = .GlobalEnv) #create results df with the right names and assign to global env
    results_list[[new_name]] <- df #populate with data for this iteration of the loop
}
```


```{r Chunk 5: Ward's clustering}

#quick and easy clustering plots for each genome partition for each pot
ward_nodES <- hclust(dissim_nodES, method = "ward.D2")
ward_nodNE <- hclust(dissim_nodNE, method = "ward.D2")
ward_complete <- hclust(dissim_complete, method = "ward.D2") 
ward_Nmetabolism <- hclust(dissim_Nmetabolism, method = "ward.D2")

wardlabels <- paste(goodqual_metadata$compartment, goodqual_metadata$Ntreatment, sep = "_")
wardlabels <- as.data.frame(wardlabels)
row.names(wardlabels) <- row.names(goodqual_metadata)
wardlabels$potID <- c("1_", "2_", "4_", "6_", "7_", "8_", "9_", "10_", "1_", "2_",  "5_", "7_", "10_", "1_", "2_", "3_", "4_", "5_")
wardlabels <- paste(wardlabels$potID, wardlabels$wardlabels, sep = "")

par(mar = c(1, 5, 2, 2) + 0.1)
plot(ward_nodES, main = "Ward's Clustering of sites by essential nodulation gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
plot(ward_nodNE, main = "Ward's Clustering of sites by nonessential nodulation gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
plot(ward_complete, main = "Ward's Clustering of sites by whole-genome fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)
plot(ward_Nmetabolism, main = "Ward's Clustering of sites by N metabolism gene fitness", ylab = "Squared Euclidean Distance", labels = wardlabels)


``` 

```{r Chunk 6: Ranked fitness, K-S, Rank-order correlation tests}


#set up row names and such to be merged and unmerged
RACmetadata <- metadata
row.names(RACmetadata) <- c("021", "022", "024", "026", "027", "028", "029", "030", "031", "032", "035", "037", "040", "041", "042", "043", "044", "045")
row.names(goodcountdat) <- c("021", "022", "024", "026", "027", "028", "029", "030", "031",  "032", "035", "037", "040", "041", "042", "043", "044", "045")

#merge metadata tags into a single unique treatment group ID
RACsubsetter <- as.data.frame(cbind(goodcountdat, RACmetadata))
RACsubsetter <- RACsubsetter %>% mutate(group = paste(compartment, Ntreatment, sep = "_"))
RACsubsetter <- RACsubsetter[, -c(5176:5177)] 

#change data to numeric
RACsubsetter <- RACsubsetter %>%
  mutate(across(1:5175, as.numeric)) 

#version of the RAC function designed to rank fitness scores, which have negative and positive values
rankfit <- function(x) {
  x <- as.data.frame(x)
  x.ranked <- x[order(rownames(x)), , drop = FALSE]
  rownames(x.ranked) <- rownames(x)[order(rownames(x))]
  return(x.ranked)
} 

#create a properly labeled and formatted dataframe to be grouped and meaned by treatment/compartment
rankfitdata <- t(goodfitdat)
row.names(rankfitdata) <- c("021", "022", "024", "026", "027", "028", "029", "030", "031", "032", "035", "037", "040", "041", "042", "043", "044", "045")
rankfitdata <- cbind(RACsubsetter$group, rankfitdata)
rankfitdata <- as.data.frame(rankfitdata)
rankfitdata <- rankfitdata %>%
  mutate(across(2:5176, as.numeric)) 

#table of meaned gene fitness per treatment/compartment group
meanfitnessrank <- rankfitdata %>%
  group_by(V1) %>%
  summarise(across(starts_with("SM"), mean)) 

#clean up and relabels rows by treatment/compartment group, make whole-genome gene fitness rank
meanfitnessrank <- as.data.frame(meanfitnessrank)
row.names(meanfitnessrank) <- meanfitnessrank[,1]
meanfitnessrank <- meanfitnessrank[,-1] 

#subsets
meanfitnessrank_Nmetab <- meanfitnessrank[, intersect(colnames(meanfitnessrank), Nmetabolism$V1)]
meanfitnessrank_nodNE <- meanfitnessrank[, intersect(colnames(meanfitnessrank), colnames(nodNEfit))]
meanfitnessrank_nodES <- meanfitnessrank[, intersect(colnames(meanfitnessrank), colnames(nodESfit))]  

#fitness rankings for the whole genome
bactambrank <-unlist(meanfitnessrank[1,])
bactfertrank <- unlist(meanfitnessrank[2,])
nodambrank <- unlist(meanfitnessrank[3,])
nodfertrank <- unlist(meanfitnessrank[4,])
t0rank <- unlist(meanfitnessrank[5,])

ranked_bactamb <- rankfit(bactambrank)
ranked_bactfert <- rankfit(bactfertrank)
ranked_nodamb <- rankfit(nodambrank)
ranked_nodfert <- rankfit(nodfertrank)
ranked_t0 <- rankfit(t0rank)

#fitness rankings for the N metabolism gene set only
Nmetab_bactambrank <-unlist(meanfitnessrank_Nmetab[1,])
Nmetab_bactfertrank <- unlist(meanfitnessrank_Nmetab[2,])
Nmetab_nodambrank <- unlist(meanfitnessrank_Nmetab[3,])
Nmetab_nodfertrank <- unlist(meanfitnessrank_Nmetab[4,])
Nmetab_t0rank <- unlist(meanfitnessrank_Nmetab[5,])

ranked_Nmetab_bactamb <- rankfit(Nmetab_bactambrank)
ranked_Nmetab_bactfert <- rankfit(Nmetab_bactfertrank)
ranked_Nmetab_nodamb <- rankfit(Nmetab_nodambrank)
ranked_Nmetab_nodfert <- rankfit(Nmetab_nodfertrank)
ranked_Nmetab_t0 <- rankfit(Nmetab_t0rank)

#NE
nodNE_bactambrank <- unlist(meanfitnessrank_nodNE[1,])
nodNE_bactfertrank <- unlist(meanfitnessrank_nodNE[2,])
nodNE_nodambrank <- unlist(meanfitnessrank_nodNE[3,])
nodNE_nodfertrank <- unlist(meanfitnessrank_nodNE[4,])
nodNE_t0rank <- unlist(meanfitnessrank_nodNE[5,])

ranked_nodNE_bactamb <- rankfit(nodNE_bactambrank)
ranked_nodNE_bactfert <- rankfit(nodNE_bactfertrank)
ranked_nodNE_nodamb <- rankfit(nodNE_nodambrank)
ranked_nodNE_nodfert <- rankfit(nodNE_nodfertrank)
ranked_nodNE_t0 <- rankfit(nodNE_t0rank)

#ES
nodES_bactambrank <- unlist(meanfitnessrank_nodES[1,])
nodES_bactfertrank <- unlist(meanfitnessrank_nodES[2,])
nodES_nodambrank <- unlist(meanfitnessrank_nodES[3,])
nodES_nodfertrank <- unlist(meanfitnessrank_nodES[4,])
nodES_t0rank <- unlist(meanfitnessrank_nodES[5,])

ranked_nodES_bactamb <- rankfit(nodES_bactambrank)
ranked_nodES_bactfert <- rankfit(nodES_bactfertrank)
ranked_nodES_nodamb <- rankfit(nodES_nodambrank)
ranked_nodES_nodfert <- rankfit(nodES_nodfertrank)
ranked_nodES_t0 <- rankfit(nodES_t0rank)

#combine
combined_nodES <- data.frame(
  nodamb = ranked_nodES_nodamb$x,
  nodfert = ranked_nodES_nodfert$x,
  bactamb = ranked_nodES_bactamb$x,
  bactfert = ranked_nodES_bactfert$x
)  

#match row names
rownames(combined_nodES) <- rownames(ranked_nodES_nodamb) 

combined_nodNE <- data.frame(
  nodamb = ranked_nodNE_nodamb$x,
  nodfert = ranked_nodNE_nodfert$x,
  bactamb = ranked_nodNE_bactamb$x,
  bactfert = ranked_nodNE_bactfert$x
)

rownames(combined_nodNE) <- rownames(ranked_nodNE_nodamb)

combined_complete <- data.frame(
  nodamb = ranked_nodamb$x,
  nodfert = ranked_nodfert$x,
  bactamb = ranked_bactamb$x,
  bactfert = ranked_bactfert$x
)

rownames(combined_complete) <- rownames(ranked_nodamb)

combined_Nmetab <- data.frame(
  nodamb = ranked_Nmetab_nodamb$x,
  nodfert = ranked_Nmetab_nodfert$x,
  bactamb = ranked_Nmetab_bactamb$x,
  bactfert = ranked_Nmetab_bactfert$x
)

rownames(combined_Nmetab) <- rownames(ranked_Nmetab_nodamb)


#Spearman correlation tests for rankfit paired datasets

# ES
spearman_nodES_bacteroid <- cor.test(combined_nodES$bactamb, combined_nodES$bactfert, method = "spearman")
spearman_nodES_nodule <- cor.test(combined_nodES$nodamb, combined_nodES$nodfert, method = "spearman")
spearman_nodES_amb <- cor.test(combined_nodES$nodamb, combined_nodES$bactamb, method = "spearman")
spearman_nodES_fert <- cor.test(combined_nodES$nodfert, combined_nodES$bactfert, method = "spearman")

# NE
spearman_nodNE_bacteroid <- cor.test(combined_nodNE$bactamb, combined_nodNE$bactfert, method = "spearman")
spearman_nodNE_nodule <- cor.test(combined_nodNE$nodamb, combined_nodNE$nodfert, method = "spearman")
spearman_nodNE_amb <- cor.test(combined_nodNE$nodamb, combined_nodNE$bactamb, method = "spearman")
spearman_nodNE_fert <- cor.test(combined_nodNE$nodfert, combined_nodNE$bactfert, method = "spearman")

# complete
spearman_complete_bacteroid <- cor.test(combined_complete$bactamb, combined_complete$bactfert, method = "spearman")
spearman_complete_nodule <- cor.test(combined_complete$nodamb, combined_complete$nodfert, method = "spearman")
spearman_complete_amb <- cor.test(combined_complete$nodamb, combined_complete$bactamb, method = "spearman")
spearman_complete_fert <- cor.test(combined_complete$nodfert, combined_complete$bactfert, method = "spearman")

# Nmetabolism
spearman_Nmetab_bacteroid <- cor.test(combined_Nmetab$bactamb, combined_Nmetab$bactfert, method = "spearman")
spearman_Nmetab_nodule <- cor.test(combined_Nmetab$nodamb, combined_Nmetab$nodfert, method = "spearman")
spearman_Nmetab_amb <- cor.test(combined_Nmetab$nodamb, combined_Nmetab$bactamb, method = "spearman")
spearman_Nmetab_fert <- cor.test(combined_Nmetab$nodfert, combined_Nmetab$bactfert, method = "spearman")

#list of all these htests for easy plotting with a for loop
all_spearman <- ls(pattern = "^spearman_") 

#plot spearman correlation tests as scatterplots

scatterplot_list <- list() 

for (test_name in all_spearman) {
  spearman_test <- get(test_name) 
  
  x_label <- switch(
    test_name,
    spearman_nodES_bacteroid = "bactamb",
    spearman_nodES_nodule = "nodamb",
    spearman_nodES_amb = "nodamb",
    spearman_nodES_fert = "nodfert",
    spearman_nodNE_bacteroid = "bactamb",
    spearman_nodNE_nodule = "nodamb",
    spearman_nodNE_amb = "nodamb",
    spearman_nodNE_fert = "nodfert",
    spearman_complete_bacteroid = "bactamb",
    spearman_complete_nodule = "nodamb",
    spearman_complete_amb = "nodamb",
    spearman_complete_fert = "nodfert",
    spearman_Nmetab_bacteroid = "bactamb",
    spearman_Nmetab_nodule = "nodamb",
    spearman_Nmetab_amb = "nodamb",
    spearman_Nmetab_fert = "nodfert"
  )
  
  y_label <- switch(
    test_name,
    spearman_nodES_bacteroid = "bactfert",
    spearman_nodES_nodule = "nodfert",
    spearman_nodES_amb = "bactamb",
    spearman_nodES_fert = "bactfert",
    spearman_nodNE_bacteroid = "bactfert",
    spearman_nodNE_nodule = "nodfert",
    spearman_nodNE_amb = "bactamb",
    spearman_nodNE_fert = "bactfert",
    spearman_complete_bacteroid = "bactfert",
    spearman_complete_nodule = "nodfert",
    spearman_complete_amb = "bactamb",
    spearman_complete_fert = "bactfert",
    spearman_Nmetab_bacteroid = "bactfert",
    spearman_Nmetab_nodule = "nodfert",
    spearman_Nmetab_amb = "bactamb",
    spearman_Nmetab_fert = "bactfert"
  ) #defines sets of labels to use for each spearman dataset
  
  rho_value <- spearman_test[["estimate"]]
  p_value <- spearman_test[["p.value"]] #get relevant data from spearman 
  
  p_value_text <- ifelse(p_value == 0, "pval < 2.2e-16", paste("pval =", formatC(p_value, format = "e", digits = 2))) #if pval is infinitesimal (ie displays 0), repalce with this statement
  
  subset_name <- switch(
    test_name,
    spearman_nodES_bacteroid = "nodES",
    spearman_nodES_nodule = "nodES",
    spearman_nodES_amb = "nodES",
    spearman_nodES_fert = "nodES",
    spearman_nodNE_bacteroid = "nodNE",
    spearman_nodNE_nodule = "nodNE",
    spearman_nodNE_amb = "nodNE",
    spearman_nodNE_fert = "nodNE",
    spearman_complete_bacteroid = "complete",
    spearman_complete_nodule = "complete",
    spearman_complete_amb = "complete",
    spearman_complete_fert = "complete",
    spearman_Nmetab_bacteroid = "Nmetab",
    spearman_Nmetab_nodule = "Nmetab",
    spearman_Nmetab_amb = "Nmetab",
    spearman_Nmetab_fert = "Nmetab"
  ) #assigns genome partition to each spearman set
  
  data_source <- switch(
    test_name,
    spearman_nodES_bacteroid = combined_nodES,
    spearman_nodES_nodule = combined_nodES,
    spearman_nodES_amb = combined_nodES,
    spearman_nodES_fert = combined_nodES,
    spearman_nodNE_bacteroid = combined_nodNE,
    spearman_nodNE_nodule = combined_nodNE,
    spearman_nodNE_amb = combined_nodNE,
    spearman_nodNE_fert = combined_nodNE,
    spearman_complete_bacteroid = combined_complete,
    spearman_complete_nodule = combined_complete,
    spearman_complete_amb = combined_complete,
    spearman_complete_fert = combined_complete,
    spearman_Nmetab_bacteroid = combined_Nmetab,
    spearman_Nmetab_nodule = combined_Nmetab,
    spearman_Nmetab_amb = combined_Nmetab,
    spearman_Nmetab_fert = combined_Nmetab
  ) #gets source df based on genome partition
  
  scatterplot <- ggplot(data = data_source, aes(x = .data[[x_label]], y = .data[[y_label]])) +
    geom_point() + #make scatterplot with correct source df and labels
    labs(x = x_label, y = y_label) +
    annotate("text", x = min(data_source[[x_label]], na.rm = TRUE), 
             y = max(data_source[[y_label]], na.rm = TRUE), 
             label = paste("rho =", round(rho_value, 2), "\n", p_value_text)) +
    ggtitle(paste("Scatterplot for", x_label, "vs.", y_label, "(", subset_name, ")"))
  
  scatterplot_list[[paste(test_name, "scatterplot", sep = "_")]] <- scatterplot #add to plot list
}


#run K-S tests on data

#function to re-sort fitness rankings from genome order (for spearman) to ascending order (for k-s tests)
ks_sort <- function(my_ranking) {
  sorted_list <- my_ranking[order(my_ranking, decreasing = TRUE)]
  name <- paste0("ks_", deparse(substitute(my_ranking)))
  names(sorted_list) <- name
  return(sorted_list)
} 

#gather all the rankings together for reordering
all_ranked <- ls(pattern = "^ranked_") 

#for loop which calls ks_sort on all the rankings. Don't know why the redundant paste0(ks_) is needed, but it is!!
for (name in all_ranked) {
  ranked_obj <- get(name)
  if (is.data.frame(ranked_obj)) {
    ranked_vec <- ranked_obj[, 1]
  } else {
    ranked_vec <- ranked_obj
  }
  sorted_vec <- ks_sort(ranked_vec)
  assign(paste0("ks_", name), sorted_vec)
} 

#whole genome ranked fitness K-S tests

ks_bacteroid_fit <- ks.test(ks_ranked_bactamb, ks_ranked_bactfert, exact = TRUE)
ks_nodule_fit <- ks.test(ks_ranked_nodamb, ks_ranked_nodfert, exact = TRUE)

ks_amb_compartment_fit <- ks.test(ks_ranked_nodamb, ks_ranked_bactamb, exact = TRUE)
ks_fert_compartment_fit <- ks.test(ks_ranked_bactfert, ks_ranked_nodfert, exact = TRUE)

#N metabolism subset

ks_bacteroid_Nmetab_fit <- ks.test(ks_ranked_Nmetab_bactamb, ks_ranked_Nmetab_bactfert, exact = TRUE)
ks_nodule_Nmetab_fit <- ks.test(ks_ranked_Nmetab_nodamb, ks_ranked_Nmetab_nodfert, exact = TRUE)

ks_amb_compartment_Nmetab_fit <- ks.test(ks_ranked_Nmetab_nodamb, ks_ranked_Nmetab_bactamb, exact = TRUE)
ks_fert_compartment_Nmetab_fit <- ks.test(ks_ranked_Nmetab_bactfert, ks_ranked_Nmetab_nodfert, exact = TRUE)

#nodES and nodNE subsets

ks_bacteroid_nodNE_fit <- ks.test(ks_ranked_nodNE_bactamb, ks_ranked_nodNE_bactfert, exact = TRUE) 
ks_nodule_nodNE_fit <- ks.test(ks_ranked_nodNE_nodamb, ks_ranked_nodNE_nodfert, exact = TRUE)

ks_amb_nodNE_fit <- ks.test(ks_ranked_nodNE_nodamb, ks_ranked_nodNE_bactamb, exact = TRUE)
ks_fert_nodNE_fit <- ks.test(ks_ranked_nodNE_nodfert, ks_ranked_nodNE_bactfert, exact = TRUE)

ks_bacteroid_nodES_fit <- ks.test(ks_ranked_nodES_bactamb, ks_ranked_nodES_bactfert, exact = TRUE)
ks_nodule_nodES_fit <- ks.test(ks_ranked_nodES_nodamb, ks_ranked_nodES_nodfert, exact = TRUE)

ks_amb_nodES_fit <- ks.test(ks_ranked_nodES_nodamb, ks_ranked_nodES_bactamb, exact = TRUE)
ks_fert_nodES_fit <- ks.test(ks_ranked_nodES_nodfert, ks_ranked_nodES_bactfert, exact = TRUE)


#combined RAC-like fitness ranking plots per dataset


#ES

#combine rankings to be plotted together
finalfitrank_nodES <- as.data.frame(rbind(as.numeric(ks_ranked_nodES_bactamb), as.numeric(ks_ranked_nodES_bactfert), as.numeric(ks_ranked_nodES_nodamb), as.numeric(ks_ranked_nodES_nodfert), as.numeric(ks_ranked_nodES_t0))) 
colnames(finalfitrank_nodES) <- 1:832
finalfitrank_nodES$treatment <- c("bact_amb", "bact_fert", "nod_amb", "nod_fert", "t0")

#flip df for plotting purposes
finalfitrank_nodES <- pivot_longer(finalfitrank_nodES, cols = colnames(finalfitrank_nodES)[1:832]) 

combinedfitrank_nodES <- ggplot(finalfitrank_nodES, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
  geom_line() +
  labs(title = "nodES fitness ranking") + xlab("Gene count") + ylab("Asinh(fitness value)")

combinedfitrank_nodES

#NE

finalfitrank_nodNE <- as.data.frame(rbind(as.numeric(ks_ranked_nodNE_bactamb), as.numeric(ks_ranked_nodNE_bactfert), as.numeric(ks_ranked_nodNE_nodamb), as.numeric(ks_ranked_nodNE_nodfert), as.numeric(ks_ranked_nodNE_t0)))
colnames(finalfitrank_nodNE) <- 1:4145
finalfitrank_nodNE$treatment <- c("bact_amb", "bact_fert", "nod_amb", "nod_fert", "t0")

finalfitrank_nodNE <- pivot_longer(finalfitrank_nodNE, cols = colnames(finalfitrank_nodNE)[1:4145])

combinedfitrank_nodNE <- ggplot(finalfitrank_nodNE, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
  geom_line() +
  labs(title = "nodNE fitness ranking")  + xlab("Gene count") + ylab("Asinh(fitness value)")

combinedfitrank_nodNE

#complete

finalfitrank_complete <- as.data.frame(rbind(as.numeric(ks_ranked_bactamb), as.numeric(ks_ranked_bactfert), as.numeric(ks_ranked_nodamb), as.numeric(ks_ranked_nodfert), as.numeric(ks_ranked_t0)))
colnames(finalfitrank_complete) <- 1:5175
finalfitrank_complete$treatment <- c("bact_amb", "bact_fert", "nod_amb", "nod_fert", "t0")

finalfitrank_complete <- pivot_longer(finalfitrank_complete, cols = colnames(finalfitrank_complete)[1:5175])

combinedfitrank_complete <- ggplot(finalfitrank_complete, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
  geom_line() +
  labs(title = "Whole-genome fitness ranking")  + xlab("Gene count") + ylab("Asinh(fitness value)")

combinedfitrank_complete

#Nmetabolism

finalfitrank_Nmetab <- as.data.frame(rbind(as.numeric(ks_ranked_Nmetab_bactamb), as.numeric(ks_ranked_Nmetab_bactfert), as.numeric(ks_ranked_Nmetab_nodamb), as.numeric(ks_ranked_Nmetab_nodfert), as.numeric(ks_ranked_Nmetab_t0)))
colnames(finalfitrank_Nmetab) <- 1:29
finalfitrank_Nmetab$treatment <- c("bact_amb", "bact_fert", "nod_amb", "nod_fert", "t0")

finalfitrank_Nmetab <- pivot_longer(finalfitrank_Nmetab, cols = colnames(finalfitrank_Nmetab)[1:29])

combinedfitrank_Nmetab <- ggplot(finalfitrank_Nmetab, aes(x = as.numeric(as.character(name)), y = asinh(value), group = treatment, color = treatment, fill = treatment)) +
  geom_line() +
  labs(title = "N metabolism fitness ranking")  + xlab("Gene count") + ylab("Asinh(fitness value)")

combinedfitrank_Nmetab

#False discovery rate adjustments and building final table

ks_objects <- ls(pattern = "^ks_.*_fit$", envir = .GlobalEnv)
ks_test_objects <- character(0)

#some objects named "ks_" are not k-s tests, but all true k-s tests are "list" type objects, so this loop goes through the ks_objects and picks only the ones that are lists, ie actual k-s tests
for (obj in ks_objects) {
  if (typeof(get(obj)) == "list") {
    ks_test_objects <- c(ks_test_objects, obj)
  }
} 

#make a landing zone for the pvals and IDs that's as long as the input df
p_values <- numeric(length(ks_test_objects)) 

#for each item in the sequence within ks_test_objects, add a value to p_values which is from that index's entry in ks_test_objects and is called [entry]$p.value
for (i in seq_along(ks_test_objects)) {
  p_values[i] <- get(ks_test_objects[i])$p.value
} 

#name them according to the test they came from
names(p_values) <- gsub("^ks_", "", ks_test_objects) 

#run the FDR and store results
adjusted_pvals_ks <- p.adjust(p_values, method = "fdr") 

ks_results_table <- data.frame(Dval = numeric(length(ks_objects)),
                               qval = numeric(length(ks_objects))) 

#get data from results objects and put them into malleable form
for (i in seq_along(ks_objects)) {
  ks_test_name <- ks_objects[i]
  ks_test_result <- get(ks_test_name)  #retrieve the K-S test result object using its name
  ks_results_table[i, "Dval"] <- ks_test_result$statistic
  ks_results_table[i, "qval"] <- adjusted_pvals_ks[[i]]
}

#set row names to corresponding K-S test
rownames(ks_results_table) <- ks_objects 

#build individual tables of k_s results for pairing with fitrank plots

#row names
row_names_nodES <- c("bact_amb/nod_amb", "bact_amb/bact_N", "bact_N/nod_N", "nod_amb/nod_N")
row_names_nodNE <- c("bact_amb/nod_amb", "bact_amb/bact_N", "bact_N/nod_N", "nod_amb/nod_N")
row_names_complete <- c("bact_amb/nod_amb", "bact_amb/bact_N", "bact_N/nod_N", "nod_amb/nod_N")
row_names_Nmetab <- c("bact_amb/nod_amb", "bact_amb/bact_N", "bact_N/nod_N", "nod_amb/nod_N") 

#pull ks test statistics and set row names to name the comparison more clearly
fitrank_nodES <- ks_results_table[c("ks_amb_nodES_fit", "ks_bacteroid_nodES_fit", "ks_fert_nodES_fit", "ks_nodule_nodES_fit"), ]
rownames(fitrank_nodES) <- row_names_nodES
fitrank_nodNE <- ks_results_table[c("ks_amb_nodNE_fit", "ks_bacteroid_nodNE_fit", "ks_fert_nodNE_fit", "ks_nodule_nodNE_fit"), ]
rownames(fitrank_nodNE) <- row_names_nodNE
fitrank_complete <- ks_results_table[c("ks_amb_compartment_fit", "ks_bacteroid_fit", "ks_fert_compartment_fit", "ks_nodule_fit"), ]
rownames(fitrank_complete) <- row_names_complete
fitrank_Nmetab <- ks_results_table[c("ks_amb_compartment_Nmetab_fit", "ks_bacteroid_Nmetab_fit", "ks_fert_compartment_Nmetab_fit", "ks_nodule_Nmetab_fit"), ]
rownames(fitrank_Nmetab) <- row_names_Nmetab 
```

```{r Chunk 7: Covariance PCA + plots}



#correlation matrices for KMO and bartlett tests
cor_nodES <- cor(covar_nodES)
cor_nodNE <- cor(covar_nodNE)
cor_complete <- cor(covar_complete)
cor_Nmetabolism <- cor(covar_Nmetab) 

# KMO(cor_nodES)
# KMO(cor_nodNE)
# KMO(cor_complete)
# KMO(cor_Nmetabolism)
#  
# cortest.bartlett(cor_nodES, n = nrow(cor_nodES))
# cortest.bartlett(cor_nodNE, n = nrow(cor_nodNE))
# cortest.bartlett(cor_complete, n = nrow(cor_complete))
# cortest.bartlett(cor_Nmetabolism, n = nrow(cor_Nmetabolism))


#PCA of covariance matrices


pca_covar_nodES <- prcomp(covar_nodES, scale = FALSE)
pca_covar_nodNE <- prcomp(covar_nodNE, scale = FALSE)
pca_covar_complete <- prcomp(covar_complete, scale = FALSE)
pca_covar_Nmetab <- prcomp(covar_Nmetab, scale = FALSE)

plot(pca_covar_nodES$x)
text(pca_covar_nodES$x, labels=rownames(pca_covar_nodES$x))
biplot(pca_covar_nodNE)
biplot(pca_covar_complete)
biplot(pca_covar_Nmetab)

head(summary(pca_covar_nodES))
head(summary(pca_covar_nodNE))
head(summary(pca_covar_complete))
head(summary(pca_covar_Nmetab))

covar_scores_nodES <- as.data.frame(pca_covar_nodES$x[, 1:2])
covar_scores_nodNE <- as.data.frame(pca_covar_nodNE$x[, 1:2])
covar_scores_complete <- as.data.frame(pca_covar_complete$x[, 1:2])
covar_scores_Nmetab <- as.data.frame(pca_covar_Nmetab$x[, 1:2])


#ES

ggplot(covar_scores_nodES, aes(x = PC1, y = PC2, color = finalmetadata$Ntreatment, shape = finalmetadata$compartment)) +
  geom_point(size = 18) +
  xlim(c(-15,20)) +
  ylim(c(-15,15)) +
  xlab("PC1 (20%)") +
  ylab("PC2 (17%)") +
  scale_color_manual(values = c("#D55E00", "#009E73")) +
  theme_bw(base_size = 30) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(size = 5, colour = "black", fill = NA),
        panel.background = element_rect(fill = "white"), axis.text.x=element_text(size=rel(1.5)),
        axis.text.y=element_text(size=rel(1.5)), axis.title.x = element_text(size = 40),
    axis.title.y = element_text(size = 40),
        axis.ticks = element_line(size = 3),  #set the size of tick marks
    axis.ticks.length = unit(0.4, "cm"),  #set the length of major ticks
    axis.ticks.margin = unit(0.8, "cm") 
    ) +
  theme(legend.position = "none") #pared down and resized for poster

ggplot(covar_scores_nodES, aes(x = PC1, y = PC2, color = finalmetadata$Ntreatment, shape = finalmetadata$compartment)) +
  geom_point(size = 18) +
  xlim(c(-15,20)) +
  ylim(c(-15,15)) +
  xlab("PC1 (20%)") +
  ylab("PC2 (17%)") +
  scale_color_manual(values = c("#D55E00", "#009E73")) +
  theme_bw(base_size = 30) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(size = 5, colour = "black", fill = NA),
        panel.background = element_rect(fill = "white"), axis.text.x=element_text(size=rel(1.5)),
        axis.text.y=element_text(size=rel(1.5)), axis.title.x = element_text(size = 40),
    axis.title.y = element_text(size = 40)) +
  theme(legend.position = "none") #pared down and resized for poster


#NE

ggplot(covar_scores_nodNE,aes(x=PC1,y=PC2, color = finalmetadata$Ntreatment, shape = finalmetadata$compartment)) +
  geom_point(size=8)+
  xlab("PC 1 (18%)") +
  ylab("PC 2 (16%)") +
  labs(title = "nodNE",color = "Ntreatment",
       shape = "Compartment") +
  theme_bw(base_size = 30) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(size = 1, colour = "black",fill=NA),
        panel.background = element_rect(fill="white"),
        axis.text.x=element_text(size=rel(0.9)),
        axis.text.y=element_text(size=rel(0.9)))

#complete

ggplot(covar_scores_complete,aes(x=PC1,y=PC2, color = finalmetadata$Ntreatment, shape = finalmetadata$compartment)) +
  geom_point(size=8)+
  xlab("PC 1 (18%)") +
  ylab("PC 2 (14%)") +
  labs(title = "complete",color = "Ntreatment",
       shape = "Compartment") +
  theme_bw(base_size = 30) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(size = 1, colour = "black",fill=NA),
        panel.background = element_rect(fill="white"),
        axis.text.x=element_text(size=rel(0.9)),
        axis.text.y=element_text(size=rel(0.9)))

#Nmetabolism

ggplot(covar_scores_Nmetab,aes(x=PC1,y=PC2, color = finalmetadata$Ntreatment, shape = finalmetadata$compartment)) +
  geom_point(size=8)+
  xlab("PC 1 (36%)") +
  ylab("PC 2 (25%)") +
  labs(title = "N metabolism",color = "Ntreatment",
       shape = "Compartment") +
  theme_bw(base_size = 30) +
  theme(panel.grid = element_blank(),
        panel.border = element_rect(size = 1, colour = "black",fill=NA),
        panel.background = element_rect(fill="white"),
        axis.text.x=element_text(size=rel(0.9)),
        axis.text.y=element_text(size=rel(0.9)))

compare_sym <- protest(pca_covar_nodES, pca_covar_nodNE, permutations=9999)

compare_sym

plot(compare_sym)

```

``` {r Chunk 8: fgsea and geseca for COGs}

#code is commented out if its only purpose is to build input files, as these only need to be run once
# 
# COGmatrices_nodES <- subset(COGmatrices, COGmatrices$essentiality == "essential")
# COGmatrices_nodNE <- subset(COGmatrices, COGmatrices$essentiality == "N") #subset data by essentiality for symbiosis
# 
# COGlist_nodES <- lapply(unique(COGmatrices_nodES$COG), function(currCOG) {
#   COG_X_ES <- COGmatrices_nodES %>%
#     filter(COG == currCOG)
# 
#   return(COG_X_ES)
# })
# 
# COGlist_nodNE <- lapply(unique(COGmatrices_nodNE$COG), function(currCOG) {
#   COG_X_NE <- COGmatrices_nodNE %>%
#     filter(COG == currCOG)
# 
#   return(COG_X_NE)
# }) #split COG_matrices into separate dataframes based on COG and symbiotic function
#    #this function and the following were written with the help of ChatGPT to fix the function(curr_cog) syntax as well as the assign() function in the following for loop
# 
# for (i in seq_along(COGlist_nodES)) {
#   currCOG <- unique(COGlist_nodES[[i]]$COG)
#   assign(paste0("COG_", currCOG, "_ES"), COGlist_nodES[[i]])
# }
# 
# for (i in seq_along(COGlist_nodNE)) {
#   currCOG <- unique(COGlist_nodNE[[i]]$COG)
#   assign(paste0("COG_", currCOG, "_NE"), COGlist_nodNE[[i]])
# } #unlists dfs into separate objects with names COG_X_[gene set]
#  
# 
# #PULL LOCUS IDS FROM EACH COG_X_[set] DF INTO VECTORS TO MAKE PATHWAYS.GMT FOR FGSEA
# 
# 
# genesetsCOG_ES <- lapply(seq_along(COGlist_nodES), function(i) {
#   df <- COGlist_nodES[[i]]
#   first_col <- as.character(df[[1]])
#   vector_name <- paste0("set", unique(df[[4]]))
#   names(first_col) <- NULL
#   names <- setNames(list(first_col), vector_name)
#   return(names)
# }) #rearranges COG information into a list of vectors to be fed into fgsea functions to build pathways file
# genesetsCOG_ES <- unlist(genesetsCOG_ES, recursive = FALSE) #final format
# 
# genesetsCOG_NE <- lapply(seq_along(COGlist_nodNE), function(i) {
#   df <- COGlist_nodNE[[i]]
#   first_col <- as.character(df[[1]])
#   vector_name <- paste0("set", unique(df[[4]]))
#   names(first_col) <- NULL
#   names <- setNames(list(first_col), vector_name)
#   return(names)
# })
# genesetsCOG_NE <- unlist(genesetsCOG_NE, recursive = FALSE)
# 
# 
# #WRITE PATHWAY FILES AND DECLARE AS VARIABLES
# 
# 
# writeGmtPathways(genesetsCOG_ES, tempfile("COGsets_ES", fileext = ".gmt")) #creates file in user/appdata/local/temp/[random id] dir which must be manually retrieved, also includes like a hexadecimal id (or maybe it's just random numbers and letters?) which I deleted
# 
# writeGmtPathways(genesetsCOG_NE, tempfile("COGsets_NE", fileext = ".gmt"))


#I added these renamed files to my R working directory
pathways_ES <- gmtPathways("COGsets_ES.gmt") 
pathways_NE <- gmtPathways("COGsets_NE.gmt")


#LOAD IN TLIKE TEST STATISTIC DATA TO BUILD RANKING FILES

tlike_data <- read.delim("C:/Users/User/Desktop/fit_t.tab")
#tlike_data <- read.delim(~/GitHub/rhizo.rb.tnseq/Data/fitness_data/html/SmeliPlant/fit_t.tab")

#remove redundant col, descr, and t0 data
tlike_data <- tlike_data[, -c(2:3)] 
tlike_data <- tlike_data[, -c(18:22)] 

#define ranges of columns containing data for each treatment/compartment combination to be averaged together
tlike_col_ranges <- list(
  nodN = c(2:5),
  nodamb = c(6:10),
  bactN = c(11:13),
  bactamb = c(14:15)
) 

#create df to be populated by meaned t-like data
tlike_data_meaned <- data.frame(ID = tlike_data$locusId) 

#go through each row of tlike_data, create new df of the proper length with the same rows as the parent, mean data within each treatment/subpopulation group
for (i in 1:nrow(tlike_data)) {
  new_values <- numeric(length(tlike_col_ranges))  
  for (j in seq_along(tlike_col_ranges)) {
    cols <- tlike_col_ranges[[j]]
    numeric_cols <- cols[sapply(tlike_data[, cols], is.numeric)] #obtains column group, checks for numeric
    numeric_values <- as.numeric(tlike_data[i, numeric_cols])
    numeric_values <- numeric_values[!is.na(numeric_values)]
    if (length(numeric_values) > 0) {
      new_values[j] <- mean(numeric_values) #if the values are numeric and no NAs, then calc mean and store values
    }
  }
  tlike_data_meaned[i, names(tlike_col_ranges)] <- new_values #new values are assigned to the correct rows in new df
}

#make sure it looks right, clean up extra row
print(tlike_data_meaned) 
row.names(tlike_data_meaned) <- tlike_data_meaned[, 1]
tlike_data_meaned <- tlike_data_meaned[, -c(1)] 

# tlike_meaned_nodN <- unlist(tlike_data_meaned[,1])
# tlike_meaned_nodamb <- unlist(tlike_data_meaned[,2])
# tlike_meaned_bactN <- unlist(tlike_data_meaned[,3])
# tlike_meaned_bactamb <- unlist(tlike_data_meaned[,4]) #due to difficulties with variable typing, the object must be unlisted into four separate objects, renamed, ranked, re-sorted, written to a .rnk file, read back into the environment as such, then converted and renamed again, before being fed into fgsea. Many of these steps are likely redundant; will be cleaned up later
# 
# names(tlike_meaned_nodN) <- rownames(tlike_data_meaned)
# names(tlike_meaned_nodamb) <- rownames(tlike_data_meaned)
# names(tlike_meaned_bactN) <- rownames(tlike_data_meaned)
# names(tlike_meaned_bactamb) <- rownames(tlike_data_meaned)
# 
# tlike_nodN_ranked <- rankfit(tlike_meaned_nodN)
# tlike_nodamb_ranked <- rankfit(tlike_meaned_nodamb)
# tlike_bactN_ranked <- rankfit(tlike_meaned_bactN)
# tlike_bactamb_ranked <- rankfit(tlike_meaned_bactamb) #rank from greatest to least
# 
# tlike_nodN_ranked <- tlike_nodN_ranked[order(-tlike_nodN_ranked$x),,drop=FALSE]
# tlike_nodamb_ranked <- tlike_nodamb_ranked[order(-tlike_nodamb_ranked$x),,drop=FALSE]
# tlike_bactN_ranked <- tlike_bactN_ranked[order(-tlike_bactN_ranked$x),,drop=FALSE]
# tlike_bactamb_ranked <- tlike_bactamb_ranked[order(-tlike_bactamb_ranked$x),,drop=FALSE] #sorts ranks by # rather than gene name

# write.table(tlike_nodN_ranked, file = "C:/Users/User/Desktop/nodN_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE)
# write.table(tlike_nodamb_ranked, file = "C:/Users/User/Desktop/nodamb_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE)
# write.table(tlike_bactN_ranked, file = "C:/Users/User/Desktop/bactN_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE)
# write.table(tlike_bactamb_ranked, file = "C:/Users/User/Desktop/bactamb_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE) #creates tab-delimited .rnk files for gene set enrichment analysis; these can be found on github at [path]

#read .rnk files back in as ranks
nodNranks <- read.table("C:/Users/User/Desktop/nodN_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
nodambranks <- read.table("C:/Users/User/Desktop/nodamb_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
bactNranks <- read.table("C:/Users/User/Desktop/bactN_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
bactambranks <- read.table("C:/Users/User/Desktop/bactamb_ranked.rnk", header=TRUE, colClasses = c("character", "numeric")) 

#nodNranks <- read.table("/home/chill37/Github/rhizo.rb.tnseq/Scripts/gsea_geseca/nodN_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
#nodambranks <- read.table("/home/chill37/Github/rhizo.rb.tnseq/Scripts/gsea_geseca/nodamb_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
#bactNranks <- read.table("/home/chill37/Github/rhizo.rb.tnseq/Scripts/gsea_geseca/bactN_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
#bactambranks <- read.table("/home/chill37/Github/rhizo.rb.tnseq/Scripts/gsea_geseca/bactamb_ranked.rnk", header=TRUE, colClasses = c("character", "numeric")) 

nodN_ranks <- as.numeric(unlist(nodNranks$x))
names(nodN_ranks) <- rownames(nodNranks)
nodamb_ranks <- as.numeric(unlist(nodambranks$x))
names(nodamb_ranks) <- rownames(nodambranks)
bactN_ranks <- as.numeric(unlist(bactNranks$x))
names(bactN_ranks) <- rownames(bactNranks)
bactamb_ranks <- as.numeric(unlist(bactambranks$x))
names(bactamb_ranks) <- rownames(bactambranks) #final retype and rename for fgsea


#RUN FGSEA AND GESECA ANALYSES


fgsea_nodN_ES <- fgsea(pathways_ES, nodN_ranks, minSize = 1, maxSize = 1100)
fgsea_nodamb_ES <- fgsea(pathways_ES, nodamb_ranks, minSize = 1, maxSize = 1100)
fgsea_bactN_ES <- fgsea(pathways_ES, bactN_ranks, minSize = 1, maxSize = 1100)
fgsea_bactamb_ES <- fgsea(pathways_ES, bactamb_ranks, minSize = 1, maxSize = 1100)

fgsea_nodN_NE <- fgsea(pathways_NE, nodN_ranks, minSize = 1, maxSize = 1100)
fgsea_nodamb_NE <- fgsea(pathways_NE, nodamb_ranks, minSize = 1, maxSize = 1100)
fgsea_bactN_NE <- fgsea(pathways_NE, bactN_ranks, minSize = 1, maxSize = 1100)
fgsea_bactamb_NE <- fgsea(pathways_NE, bactamb_ranks, minSize = 1, maxSize = 1100)

require("preprocessCore")

#the normalize.quantiles function erases row names so some shenanigans are needed
geseca_data <- tlike_data
geseca_data <- geseca_data[, -c(1)] 
geseca_data <- normalize.quantiles(as.matrix(geseca_data))
geseca_data <- as.data.frame(geseca_data)
rownames(geseca_data) <- tlike_data$locusId

geseca_rbtnseq_ES <- geseca(pathways_ES, geseca_data, minSize = 1, maxSize = 1100)
geseca_rbtnseq_NE <- geseca(pathways_NE, geseca_data, minSize = 1, maxSize = 1100)

```


``` {r Chunk 9: KEGG analyses}

#LOAD IN DATA AND REMATCH NEW LOCUS TAGS TO GET MORE ANNOTATIONS

newtags <- fitmetadata[, c(1, 2, 5, 10, 11, 18)]

# newtags <- newtags[, -c(1, 3, 4, 5)]
# newtags <- newtags[complete.cases(newtags), ]
# write.csv(newtags, "C:/Users/User/Desktop/aaseq2_newIDs_smeliplant.csv", row.names = FALSE) #this was submitted to blastKOALA to reannotate the genome in case there are any kegg kos associated with only the new tags

#remove extraneous column used to generate csv file for reannotation
newtags <- newtags[, -c(6)] 
newtags$KEGG_ko <- NA

#match kegg KOs associated with old locus tags to the tags here to create kegg KO list
for (i in 1:nrow(newtags)) {
  locus_tag <- newtags[i, "locus_tag"]
    match_row <- KEGGcomplete$locus_tag == locus_tag
    if (any(match_row)) {
    newtags[i, "KEGG_ko"] <- KEGGcomplete$KEGG_ko[match_row]
  }
} 

#df containing tags matched by blastKOALA to new locus tags, in case we can get more KEGG information that way
newtag_KEGG <- read.csv("C:/Users/User/Desktop/new_locustags_keggko.csv") 

#match new locus tags in newtags to new locus tags in newtag_KEGG, and copy over new Kegg kos only if they are NOT - or NA. Just in case annotations aren't consistent between the old and new tags
for (i in 1:nrow(newtags)) {
  new_locus_tag <- newtags[i, "new.locus.tag"]
  match_row <- newtag_KEGG$new.locus.tag == new_locus_tag & !is.na(newtag_KEGG$new.locus.tag)
  
  if (any(match_row, na.rm = TRUE)) {
    keggko <- newtag_KEGG$KEGG_ko[match_row]
    
    if (!is.na(keggko) && !grepl("^-", keggko) && grepl("^K", keggko)) {
      newtags[i, "KEGG_ko"] <- keggko
    }
  }
} 

#cleans up KEGG ids by removing "ko:" leading characters from some kos
for (i in 1:nrow(newtags)) {
  keggko <- newtags[i, "KEGG_ko"]
  if (!is.na(keggko) && grepl("ko:", keggko)) {
    newtags[i, "KEGG_ko"] <- gsub("ko:", "", keggko, fixed = FALSE)
  }
} 

#load in fitness data and merge with cleaned-up and reannotated KEGG tags
KEGGfitdata <- t(completefit)
KEGGfitmetadata <- merge(newtags, KEGGfitdata, by.x = "locus_tag", by.y = "row.names", all.x = TRUE) 
#splits and duplicates rows with kos like this: id/id. These are separate genes in a two-gene operon which are annotated as one for some
KEGGfitmetadata <- KEGGfitmetadata %>%
  separate_rows(KEGG_ko, sep = "/") 


#PREP DATA FOR CONTINGENCY TABLES

#same process as COG analysis; picks out numeric data to be worked with
KEGGnumeric_cols <- which(sapply(KEGGfitmetadata, is.numeric)) 

#replace fitness values over >=1 with 1, between 1 and -1 with 0, <= -1 with -1
for (col in KEGGnumeric_cols) {
  KEGGfitmetadata[[col]] <- ifelse(KEGGfitmetadata[[col]] <= -1, -1,
                                       ifelse(KEGGfitmetadata[[col]] >= 1, 1, 0))
} 

for (i in 1:nrow(KEGGfitmetadata)) {
  if (any(is.na(KEGGfitmetadata[i, ]))) {
    KEGGfitmetadata <- KEGGfitmetadata[-i, ]
  }
} 

#clean up pathway row before shuffling stuff around
KEGGfitmetadata$KEGG_Pathway <- trimws(KEGGfitmetadata$KEGG_Pathway) 

#expand pathway id list and duplicate rows, putting one koXXXXX id in each row
expanded_rows <- data.frame(KEGG_Pathway = character(), stringsAsFactors = FALSE)
for (i in seq_len(nrow(KEGGfitmetadata))) {
  pathway_ids <- unlist(strsplit(as.character(KEGGfitmetadata[i, "KEGG_Pathway"]), ",")) #split pathway id cells
  pathway_ids <- pathway_ids[!grepl("^map\\d{5}$", pathway_ids)] #get rid of map ids
  
  for (pathway_id in pathway_ids) {
    new_row <- KEGGfitmetadata[i, ]
    new_row[["KEGG_Pathway"]] <- trimws(pathway_id) #duplicate rows containing multiple pathway ids
    expanded_rows <- rbind(expanded_rows, new_row) #add duplicate row to recipient df
  }
} 

KEGGfitmetadata <- expanded_rows[complete.cases(expanded_rows), , drop = FALSE] #removes rows with NAs

#new env to store all the pathway dfs
KEGGfit_env <- new.env() 
#split KEGGfitmetadata into list of dfs based on pathway ids
KEGGfit_list <- split(KEGGfitmetadata, KEGGfitmetadata$KEGG_Pathway) 
for (i in seq_along(KEGGfit_list)) {
  pathway_id <- names(KEGGfit_list)[i]  #get pathway id
  df <- KEGGfit_list[[i]]  #get df for the current pathway id
  
  df_name <- paste0("KEGG_", pathway_id)
  assign(df_name, df, envir = KEGGfit_env)
}


#MAKE CONTINGENCY TABLES

#delete subset containing unannotated genes
rm("KEGG_-", envir = KEGGfit_env) 

#deletes gene sets with fewer than 6 genes represented
KEGGfit_env <- lapply(KEGGfit_env, function(df) {
  if (nrow(df) >= 6) {
    return(df)
  }
  return(NULL)
}) 

#for the remaining gene sets, delete the t0 data and the redundant pathway column
KEGGfit_env <- lapply(KEGGfit_env, function(df) {
  if (!is.null(df)) {
    df <- df %>%
      select(-c(5, 19:23))
    return(df)
  }
  return(NULL)
}) 

#clean up all the nulled stuff
KEGGfit_env <- KEGGfit_env[!sapply(KEGGfit_env, is.null)] 

#condense categorical data into row totals

#make empty list for condensed_dfs to be put into KEGGfit env at the end
condensed_dfs <- list() 

#have to do things this way since KEGGfit_env was made with new.env()
df_names <- ls(KEGGfit_env) 
#condense data into total frequencies of each fitness level
for (df_name in df_names) {
  df <- KEGGfit_env[[df_name]]
  
  negatives <- rowSums(df[, 5:17] == -1)
  zeros <- rowSums(df[, 5:17] == 0)
  positives <- rowSums(df[, 5:17] == 1) #total up the frequency of 1s, 0s, and -1s in the fitness values of each df
  
  condensed_df <- df %>% 
    select(essentiality) %>%
    mutate(negative = negatives, neutral = zeros, positive = positives) #replace fitness data with tabulated counts
  
  condensed_dfs[[df_name]] <- condensed_df
} 
KEGGfit_env <- list2env(condensed_dfs) #put condensed_dfs into KEGGfit_env

#make final contingency tables
ko_tables <- vector("character", length = length(ls(KEGGfit_env)) * 2) 

#keep track of df index in loop (weird system suggested by chatGPT after several attempts to manually adapt the COGtables loop for this purpose)
df_index <- 1 
for (df_name in ls(KEGGfit_env)) {
  df <- KEGGfit_env[[df_name]]
    ko_id <- substr(df_name, nchar(df_name) - 4, nchar(df_name)) #extract kegg pathway id from df name
  
  positive_essential <- sum(df$positive[df$essentiality == "essential"])
  positive_N <- sum(df$positive[df$essentiality == "N"])
  neutral_essential <- sum(df$neutral[df$essentiality == "essential"])
  neutral_N <- sum(df$neutral[df$essentiality == "N"]) #total up values for positive tables
  
  df_positive <- data.frame(
    positive = c(positive_essential, positive_N) / 13,
    neutral = c(neutral_essential, neutral_N) / 13
  ) 
  df_positive <- round(df_positive)
  rownames(df_positive) <- c("essential", "N") #divide by n to get mean values and add to df with proper row names for essentiality category
    df_positive_name <- paste0("ko", ko_id, "_positive")
  assign(df_positive_name, df_positive, envir = KEGGfit_env)
  ko_tables[(df_index * 2) - 1] <- df_positive_name #assign positive tables to KEGGfit_env and update index
  
  negative_essential <- sum(df$negative[df$essentiality == "essential"])
  negative_N <- sum(df$negative[df$essentiality == "N"])
  neutral_essential <- sum(df$neutral[df$essentiality == "essential"])
  neutral_N <- sum(df$neutral[df$essentiality == "N"]) #total up values for negative tables
  
  df_negative <- data.frame(
    negative = c(negative_essential, negative_N) / 13,
    neutral = c(neutral_essential, neutral_N) / 13
  )
  df_negative <- round(df_negative)
  rownames(df_negative) <- c("essential", "N") #make negative tables of mean values
  df_negative_name <- paste0("ko", ko_id, "_negative")
  assign(df_negative_name, df_negative, envir = KEGGfit_env)
  ko_tables[df_index * 2] <- df_negative_name #assign negative tables to KEGGfit_env
  
  df_index <- df_index + 1
}

kegg_source_objects <- grep("^KEGG_", ls(KEGGfit_env), value = TRUE)
#delete source dfs, leaving only the tabulated contingency tables 
rm(list = kegg_source_objects, envir = KEGGfit_env) 


#FISHER TESTS

#run fisher's exact tests on each object in KEGGfit_env
for (df_name in ls(KEGGfit_env)) {
  df <- KEGGfit_env[[df_name]]
  result_name <- paste0("fisher_", df_name)
  KEGGfit_env[[result_name]] <- fisher.test(df, simulate.p.value = FALSE)
} 

#retrieve KEGG fisher tests
fisher_KEGG <- ls(pattern = "^fisher_ko", envir = KEGGfit_env) 

#retrieve p values
fisher_KEGG_pvals <- numeric(length(fisher_KEGG))
for (j in seq_along(fisher_KEGG)) {
  fisher_KEGG_pvals[j] <- KEGGfit_env[[fisher_KEGG[j]]]$p.value
}  

#trim names and fdr adjust p vals
names(fisher_KEGG_pvals) <- gsub("^fisher_", "", fisher_KEGG)
adjusted_fisher_KEGG_pvals <- p.adjust(fisher_KEGG_pvals, method = "fdr") 

#fgsea and geseca

#make pathways files; same rankings from COG analyses can be reused here

#partitions by essentiality
KEGGfit_pathwaysets <- lapply(names(KEGGfit_list), function(name) {
  df <- KEGGfit_list[[name]]
  df_ES <- df %>% filter(essentiality == "essential")
  df_NE <- df %>% filter(essentiality == "N")
  setNames(list(df_ES, df_NE), c(paste0(name, "_ES"), paste0(name, "_NE")))
}) 

#remove very small pathways that can create spurious hits
KEGGfit_pathwaysets <- KEGGfit_pathwaysets[sapply(KEGGfit_pathwaysets, function(x) nrow(x[[1]]) >= 4 && nrow(x[[2]]) >= 4)] 

#remove t0 columns from analysis
KEGGfit_pathwaysets <- lapply(KEGGfit_pathwaysets, function(tibble_list) {
  tibble_list[[1]] <- tibble_list[[1]][, -c((ncol(tibble_list[[1]]) - 4):ncol(tibble_list[[1]]))]
  tibble_list[[2]] <- tibble_list[[2]][, -c((ncol(tibble_list[[2]]) - 4):ncol(tibble_list[[2]]))]
  tibble_list
}) 

library(purrr) #required for some list-related functions

#splits dfs into essential and nonessential according to partition above
KEGGfit_pathways_ES <- map(KEGGfit_pathwaysets, function(sublist) {
  df_ES <- sublist[[grep("_ES", names(sublist))]]
  return(df_ES)
}) 
KEGGfit_pathways_NE <- map(KEGGfit_pathwaysets, function(sublist) {
  df_NE <- sublist[[grep("_NE", names(sublist))]]
  return(df_NE)
}) 

#grabs all gene IDs from col 1 corresponding to a unique KEGG pathway id from col 5, then puts those IDs in a list named after that KEGG pathway set
get_genesets <- function(df) {
  pathway <- unique(df$KEGG_Pathway)
  geneset <- unname(unlist(df[[1]]))
  return(setNames(list(geneset), paste0("set_", pathway)))
} 

#stores ES and NE sets as lists of character vectors and removes the redundant level of organization
genesetsKEGG_ES <- unlist(map(KEGGfit_pathways_ES, get_genesets), recursive = FALSE)
genesetsKEGG_NE <- unlist(map(KEGGfit_pathways_NE, get_genesets), recursive = FALSE) 

#make pathways file for fgsea
writeGmtPathways(genesetsKEGG_ES, tempfile("KEGGsets_ES", fileext = ".gmt"))
writeGmtPathways(genesetsKEGG_NE, tempfile("KEGGsets_NE", fileext = ".gmt")) 

#it takes a lot of steps to make the .gmt file for some reason
pathways_keggES <- gmtPathways("KEGGsets_ES.gmt")
pathways_keggNE <- gmtPathways("KEGGsets_NE.gmt") 

#run analyses

KEGG_fgsea_nodN_ES <- fgsea(pathways_keggES, nodN_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_nodamb_ES <- fgsea(pathways_keggES, nodamb_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_bactN_ES <- fgsea(pathways_keggES, bactN_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_bactamb_ES <- fgsea(pathways_keggES, bactamb_ranks, minSize = 1, maxSize = 1100)

KEGG_fgsea_nodN_NE <- fgsea(pathways_keggNE, nodN_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_nodamb_NE <- fgsea(pathways_keggNE, nodamb_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_bactN_NE <- fgsea(pathways_keggNE, bactN_ranks, minSize = 1, maxSize = 1100)
KEGG_fgsea_bactamb_NE <- fgsea(pathways_keggNE, bactamb_ranks, minSize = 1, maxSize = 1100)

KEGG_geseca_rbtnseq_ES <- geseca(pathways_keggES, geseca_data, minSize = 1, maxSize = 1100)
KEGG_geseca_rbtnseq_NE <- geseca(pathways_keggNE, geseca_data, minSize = 1, maxSize = 1100)

```


``` {r Chunk 10: Plot fgsea results}

#plot fgsea results and create enrichment plots and gsea tables

all_fgsea_cog <- ls(pattern = "fgsea", envir = globalenv()) 

#get rid of unannotated result sets
for (df_name in all_fgsea_cog) {
  df <- get(df_name)
    df <- df[!grepl("set-|set_-", df[[1]]), ]
    assign(df_name, df, envir = .GlobalEnv)
}

#plot fgsea results for each partition and set
for (fgsea_name in all_fgsea_cog) {
  fgsea_obj <- get(fgsea_name)

  switch_value <- fgsea_name

  if (fgsea_name %in% c("fgsea_nodN_ES", "fgsea_nodamb_ES", "fgsea_bactN_ES", "fgsea_bactamb_ES")) {
    switch_value <- "ES"
  } else if (fgsea_name %in% c("fgsea_nodN_NE", "fgsea_nodamb_NE", "fgsea_bactN_NE", "fgsea_bactamb_NE")) {
    switch_value <- "NE"
  } else if (fgsea_name %in% c("KEGG_fgsea_nodN_ES", "KEGG_fgsea_nodamb_ES", "KEGG_fgsea_bactN_ES", "KEGG_fgsea_bactamb_ES")) {
    switch_value <- "KEGG_ES"
  } else if (fgsea_name %in% c("KEGG_fgsea_nodN_NE", "KEGG_fgsea_nodamb_NE", "KEGG_fgsea_bactN_NE", "KEGG_fgsea_bactamb_NE")) {
    switch_value <- "KEGG_NE"
  } #define naming parameters for each type of result set so that the correct ranking and pathway files can be referenced for each plot

  if (switch_value == "ES") {
    pathways_file <- pathways_ES
    ranks_file <- switch(fgsea_name,
      "fgsea_nodN_ES" = nodN_ranks,
      "fgsea_nodamb_ES" = nodamb_ranks,
      "fgsea_bactN_ES" = bactN_ranks,
      "fgsea_bactamb_ES" = bactamb_ranks
    )
  } else if (switch_value == "NE") {
    pathways_file <- pathways_NE
    ranks_file <- switch(fgsea_name,
      "fgsea_nodN_NE" = nodN_ranks,
      "fgsea_nodamb_NE" = nodamb_ranks,
      "fgsea_bactN_NE" = bactN_ranks,
      "fgsea_bactamb_NE" = bactamb_ranks
    )
  } else if (switch_value == "KEGG_ES") {
    pathways_file <- pathways_keggES
    ranks_file <- switch(fgsea_name,
      "KEGG_fgsea_nodN_ES" = nodN_ranks,
      "KEGG_fgsea_nodamb_ES" = nodamb_ranks,
      "KEGG_fgsea_bactN_ES" = bactN_ranks,
      "KEGG_fgsea_bactamb_ES" = bactamb_ranks
    )
  } else if (switch_value == "KEGG_NE") {
    pathways_file <- pathways_keggNE
    ranks_file <- switch(fgsea_name,
      "KEGG_fgsea_nodN_NE" = nodN_ranks,
      "KEGG_fgsea_nodamb_NE" = nodamb_ranks,
      "KEGG_fgsea_bactN_NE" = bactN_ranks,
      "KEGG_fgsea_bactamb_NE" = bactamb_ranks
    ) #employ switching parameters to use the correct metadata files for each type of result set
  }

  topPathwaysUp <- fgsea_obj[ES > 0 & padj < 0.2]
  topPathwaysUp_sorted <- topPathwaysUp[head(order(padj), length(topPathwaysUp)), pathway]
  topPathwaysDown <- fgsea_obj[ES < 0 & padj < 0.2]
  topPathwaysDown_sorted <- c(topPathwaysUp_sorted, rev(topPathwaysDown[head(order(padj), length(topPathwaysDown)), pathway]))
  topPathways <- c(topPathwaysUp_sorted, rev(topPathwaysDown_sorted)) #code adapted from davetang.org; adds most-enriched or -depleted pathways to table

  print(plotGseaTable(pathways_file[unique(topPathways)], ranks_file, fgsea_obj, pathwayLabelStyle = list(size=30), headerLabelStyle = list(size=40), valueStyle = list(size=30), axisLabelStyle = list(size=20), gseaParam = 0.15))
  topPathwayEnrich <- head(fgsea_obj[order(pval), ], 1)$pathway
  print(plotEnrichment(pathways_file[[topPathwayEnrich]], ranks_file) + labs(title = topPathwayEnrich)) #print both types of plots
}


#make poster-friendly boxish plots of fgsea data

df_list <- list()

#retrieve and reorganize input data
for (object_name in all_fgsea_cog) {
  fgsea_df <- get(object_name) #retrieve data from name
    fgsea_df <- fgsea_df %>%
    mutate(group = object_name) #add a col denoting the source analysis for each row of data
    df_list[[object_name]] <- fgsea_df
}

#combine
fgsea_collated <- bind_rows(df_list) 

#remove unannotated sets from data
fgsea_collated <- fgsea_collated %>%
  filter(!grepl("set-|set_-", pathway)) 

#split into ES and NE for plotting purposes
fgsea_collated_ES <- fgsea_collated %>%
  filter(grepl("_ES$", group))
fgsea_collated_NE <- fgsea_collated %>%
  filter(grepl("_NE$", group)) 

#remove redundant tags, trim down to just treatment/compartment combination
fgsea_collated_ES$group <- sub("_ES$", "", fgsea_collated_ES$group)
fgsea_collated_NE$group <- sub("_NE$", "", fgsea_collated_NE$group) 
fgsea_collated_ES$group <- sub("fgsea_", "", fgsea_collated_ES$group)
fgsea_collated_NE$group <- sub("fgsea_", "", fgsea_collated_NE$group) 

#create paired dfs for easy plotting of comparisons
fgsea_plotting <- new.env() 
group_pairs <- list(c("bactamb", "bactN"), c("nodamb", "nodN"), c("KEGG_bactamb", "KEGG_bactN"), c("KEGG_nodamb", "KEGG_nodN"))
for (group_pair in group_pairs) {
  group1 <- group_pair[1]
  group2 <- group_pair[2] #get individual group names from the pair list
    df_ES <- fgsea_collated_ES[fgsea_collated_ES$group %in% c(group1, group2), ]
    df_NE <- fgsea_collated_NE[fgsea_collated_NE$group %in% c(group1, group2), ]
  
  assign(paste0("fgsea_collated_", group1, "_", group2, "_ES"), df_ES, envir = fgsea_plotting)
  assign(paste0("fgsea_collated_", group1, "_", group2, "_NE"), df_NE, envir = fgsea_plotting) #make new dfs
}
ls(envir = fgsea_plotting)

#replace group names for plotting purposes
replace_group_names <- function(group_name) {
  replacements <- c(
    "bactamb" = "ambient",
    "nodamb" = "ambient",
    "KEGG_bactamb" = "ambient",
    "KEGG_nodamb" = "ambient",
    "bactN" = "enriched",
    "nodN" = "enriched",
    "KEGG_bactN" = "enriched",
    "KEGG_nodN" = "enriched"
  ) 
  
  for (pattern in names(replacements)) {
    if (grepl(pattern, group_name)) {
      return(replacements[pattern])
    }
  }   #check if the group_name matches any pattern, and replace accordingly
  
  return(group_name) #return original if no match found
}

#replace group names and reassign
for (df_name in ls(envir = fgsea_plotting)) {
  df <- get(df_name, envir = fgsea_plotting)
  
  df$group <- sapply(df$group, replace_group_names) #replace group names for all data to be plotted
  
  assign(df_name, df, envir = fgsea_plotting) #reassign
}

unique(fgsea_plotting$fgsea_collated_ES$group)
unique(fgsea_plotting$fgsea_collated_NE$group)


df_names <- ls(envir = fgsea_plotting) #get dfs for plotting
y_limits <- c(0, 1.75) #set universal scale for y axis

for (df_name in df_names) {
  df <- get(df_name, envir = fgsea_plotting) #plot each paired comparison
    p <- ggplot(data = as.data.frame(df), aes(y = -log10(as.numeric(as.character(padj))), x = -as.numeric(as.character(NES)))) +
    geom_point(size = 15) +
      labs(x = NULL, y = NULL) +
    facet_grid(. ~ group) +
    geom_hline(aes(yintercept = -log10(0.2))) +
    theme_bw(base_size = 60) +
    theme(panel.grid = element_blank(),
          panel.border = element_rect(size = 2, colour = "black", fill = NA),
          panel.background = element_rect(fill = "white"),
          axis.text.x = element_text(size = rel(1.2)),
          axis.text.y = element_text(size = rel(1.2))) +
    ylim(y_limits)
  
  print(p)
}



```

``` {r Chunk 11: Leading-edge and "rank-shift"}


#retrieve all the leading-edge genes and their info according to gene id
leadingEdge_extracted <- new.env()
for (obj in all_fgsea_cog) {
  fgsea_df <- get(obj) 
    leading_edge_list <- fgsea_df$leadingEdge #get the list of lists of leading edge genes from each input df
  
  all_gene_ids <- unlist(leading_edge_list) 
  unique_gene_ids <- unique(all_gene_ids) #pool all genes and remove any redundant ones
  
  list_name <- paste(obj, "_leading", sep = "")
  assign(list_name, unique_gene_ids, envir = leadingEdge_extracted) #store in dedicated env to reduce clutter
}

#Extract leading-edge genes from fgsea results
leadingEdge_extracted <- new.env()

for (obj in all_fgsea_cog) {
  fgsea_df <- get(obj) #retrieve object from indexed name
    filtered_leading_edge <- fgsea_df$leadingEdge[fgsea_df$padj <= 0.2] #filter out leadingedge lists from nonsignificant gene sets and get the significant ones
    unique_genes <- unique(unlist(filtered_leading_edge)) #pool and filter for unique genes
    extracted_name <- paste(obj, "_leading", sep = "")
    assign(extracted_name, unique_genes, envir = leadingEdge_extracted) #rename each list and collect in dedicated env to reduce clutter
}


#create pooled list of all significant genes and get their metadata from the complete gene metadata list

#get only unique gene ids from the env (may be redundant)
all_gene_ids <- unique(unlist(as.list(leadingEdge_extracted))) 

#if there is a matching row for a leading edge gene in the master df containing all gene data, pull that data from the master df into a new one
leadingEdge_allgenes <- data.frame()
for (gene_id in all_gene_ids) {
  matching_row <- KEGGcomplete[KEGGcomplete$locus_tag == gene_id, ]
  if (nrow(matching_row) > 0) {
    leadingEdge_allgenes <- rbind(leadingEdge_allgenes, matching_row)
  }
} 
row.names(leadingEdge_allgenes) <- NULL


#"Rank-shift" analysis comparing rank-orders between replicates


#splits rank fitness data into treatment groups
split_dfs <- split(rankfitdata, rankfitdata$V1) 
names(split_dfs) <- paste0(names(split_dfs), "_genomeorder")
split_dfs <- lapply(split_dfs, function(df) df[, -which(names(df) == "V1")])

#splits each df into individual vectors each containing 1 of the replicates
list_of_vectors <- lapply(split_dfs, function(df) {
  apply(df, 1, function(row) {
    names(row) <- colnames(df)
    return(row)
  })
}) 

#converts double to df, preserving row/col names
for (i in seq_along(list_of_vectors)) {
  vector_name <- names(list_of_vectors)[i]
  df <- as.data.frame(t(list_of_vectors[[i]]))
  rownames(df) <- colnames(list_of_vectors[[i]]) 

  assign(vector_name, df, envir = .GlobalEnv)
}

genomeorder_dfs <- grep("_genomeorder$", ls(), value = TRUE)
genomeorder_replicates <- list()

#splits all dfs in genomeorder_dfs into constituent rows, preserving row/col names
for (df_name in genomeorder_dfs) {
  df <- get(df_name)
  for (row_name in rownames(df)) {
    row_vector <- df[row_name, , drop = FALSE]
    vector_name <- paste0(df_name, "_", row_name)
    genomeorder_replicates[[vector_name]] <- row_vector
  }
} 

#function to sort the genome-order dfs into increasing order by fitness score while preserving names
rank_sort <- function(my_ranking_df) {
  row_vector <- unlist(my_ranking_df)
    sorted_indices <- order(row_vector, decreasing = FALSE)
  sorted_values <- row_vector[sorted_indices]
  sorted_names <- names(row_vector)[sorted_indices] #sorts names along with numerical data
  
  sorted_df <- data.frame(setNames(sorted_values, sorted_names), stringsAsFactors = FALSE)
  return(sorted_df) #returns sorted df as new object
}

#sort
rankorder_replicates <- lapply(genomeorder_replicates, rank_sort)

#modify names to reflect re-ordering and reassign
replicate_names <- names(rankorder_replicates)
replicate_names <- gsub("_genome", "_rank", replicate_names, fixed = TRUE) 
names(rankorder_replicates) <- replicate_names

#flips them to same orientation as genome order objects
rankorder_replicates <- lapply(rankorder_replicates, t) 
for (i in seq_along(rankorder_replicates)) {
  rownames(rankorder_replicates[[i]]) <- NULL
}

rankorder_replicates <- lapply(rankorder_replicates, t)
genomeorder_replicates <- lapply(genomeorder_replicates, t)

# rankshift_reference <- rankorder_replicates[["bact_ambient_rankorder_037"]]
# rankshift_query <- rankorder_replicates[["bact_ambient_rankorder_040"]]
# 
# rankshift_crosstreatment <- rankorder_replicates[["bact_fertilized_rankorder_031"]]
# 
# rankshift_ct_sorted <- rankshift_crosstreatment[rownames(rankshift_reference), , drop = FALSE]
# 
# test_rankshift_comparison <- rankshift_query[rownames(rankshift_reference), , drop = FALSE]
# 
# rankshift_test <- cor.test(rankshift_reference, test_rankshift_comparison, method = "pearson")
# 
# rankshift_ct_test <- cor.test(rankshift_reference, rankshift_ct_sorted, method = "pearson")


rankshift_results <- new.env()

#goes through rankshift dataset, making all possible combinations of comparisons excluding self-comparisons
n <- length(rankorder_replicates) #create index variable to facilitate pairwise comparisons
for (i in seq_len(n)) {
  for (j in seq_len(n)) {
    
    if (i != j && j > i) { #this rule prevents self-comparisons or repeated comparisons
      
      query_set <- rankorder_replicates[[i]]
      reference_set <- rankorder_replicates[[j]] #the two rank-orders to be tested
      
      sorted_query_set <- query_set[rownames(reference_set), ] #sort the query set to match the order of the ref
      
      correlation_result <- cor.test(sorted_query_set, reference_set, method = "pearson") #cor test
      
      result_name <- paste0(substr(names(rankorder_replicates)[i], nchar(names(rankorder_replicates)[i]) - 2, nchar(names(rankorder_replicates)[i])),
                              "_", substr(names(rankorder_replicates)[j], nchar(names(rankorder_replicates)[j]) - 2, nchar(names(rankorder_replicates)[j]))) #name result based on input datasets
      
      assign(result_name, correlation_result, envir = rankshift_results)
            print(correlation_result) #assign to env and print result
    }
  }
}

#create an empty dataframe to store the results
rankshift_plotting <- data.frame(list_name = character(), correlation = numeric())

#iterate over each object in rankshift_results and add to plotting df
for (result_name in ls(rankshift_results)) {
  correlation <- rankshift_results[[result_name]][["estimate"]][["cor"]] #get name
  
  rankshift_plotting <- rbind(rankshift_plotting, data.frame(list_name = result_name, correlation = correlation))
} 
head(rankshift_plotting)

#filter out t0
pattern <- "04[1-5]"
rankshift_plotting <- rankshift_plotting[!grepl(pattern, rankshift_plotting$list_name), ] 

#clean up names of objects by making sure the numbers are least to greatest
for (i in 1:nrow(rankshift_plotting)) {
  parts <- unlist(strsplit(as.character(rankshift_plotting[i, 1]), "_")) 
  if (as.numeric(parts[2]) < as.numeric(parts[1])) {   #if the second part is less than the first part...
    rankshift_plotting[i, 1] <- paste(parts[2], parts[1], sep = "_")  #...then swap the parts and update the df
  }
}
rankshift_plotting <- rankshift_plotting[order(as.numeric(substr(rankshift_plotting$list_name, 1, 3))), ]


#add a new col "comparison" to rankshift_plotting
rankshift_plotting$comparison <- NA

#make comparison name based on the list_name
generate_comparison_name <- function(name) {
  first_number <- substr(name, 1, 3)
  second_number <- substr(name, 5, 7) #get the two three-digit numbers
  
#comparison name generated as follows based on numbers retrieved  
  if (first_number %in% c("021", "022", "024", "031", "032", "035")) {
    first_name <- "+N"
  } else if (first_number %in% c("026", "027", "028", "029", "030", "037", "040")) {
    first_name <- "-N"
  } else {
    first_name <- first_number
  }
  
  if (second_number %in% c("021", "022", "024", "031", "032", "035")) {
    second_name <- "+N"
  } else if (second_number %in% c("026", "027", "028", "029", "030", "037", "040")) {
    second_name <- "-N"
  } else {
    second_name <- second_number
  }
  
  # Generate the comparison name
  comparison_name <- paste0(first_name, " vs ", second_name)
  
  return(comparison_name)
}

#apply function
rankshift_plotting$comparison <- sapply(rankshift_plotting$list_name, generate_comparison_name)

#add new col "subpopulation" to rankshift_plotting
rankshift_plotting$subpopulation <- NA

#generate subpopulation name based on list_name, same idea as above
generate_subpopulation_name <- function(name) {
  first_number <- substr(name, 1, 3)
  second_number <- substr(name, 5, 7)
  
  if (first_number %in% c("021", "022", "024", "026", "027", "028", "029", "030")) {
    first_name <- "Nodule"
  } else if (first_number %in% c("031", "032", "035", "037", "040")) {
    first_name <- "Bacteroid"
  } else {
    first_name <- first_number
  }
  
  if (second_number %in% c("021", "022", "024", "026", "027", "028", "029", "030")) {
    second_name <- "Nodule"
  } else if (second_number %in% c("031", "032", "035", "037", "040")) {
    second_name <- "Bacteroid"
  } else {
    second_name <- second_number
  }
  
  subpopulation_name <- paste0(first_name, " vs ", second_name)
  
  return(subpopulation_name)
}

#apply
rankshift_plotting$subpopulation <- sapply(rankshift_plotting$list_name, generate_subpopulation_name)

#clean up names and reorganize
rankshift_plotting <- rankshift_plotting[, c("list_name", "subpopulation", "comparison", "correlation")]
rankshift_plotting$comparison <- gsub("-N vs \\+N", "+N vs -N", rankshift_plotting$comparison)

#scatterplot
rankshift_plot <- 
ggplot(rankshift_plotting, aes(x = comparison, y = correlation, color = comparison)) +
  geom_point(position = position_jitter(width = 0.2), size = 3) +
  geom_smooth(method = "lm", se = FALSE) + 
  labs(x = "Comparison", y = "Correlation Coefficient") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),  
        axis.text.y = element_text(size = 12),  
        axis.title = element_text(size = 14),  
        legend.text = element_text(size = 12), 
        legend.title = element_text(size = 14), 
        plot.margin = margin(1, 1, 1, 1, "cm")) +  
  scale_color_manual(values = c("#FF0000", "#00FF00", "#0000FF"),
                     breaks = c("+N vs +N", "-N vs -N", "+N vs -N"),
                     labels = c("+N vs +N", "-N vs -N", "+N vs -N"))


```

``` {r Chunk 12: Replicon distribution analysis}

#pSym proportion analysis

symbiotic_plasmid_count <- 0
chromosome_count <- 0

#count genes on each replicon for whole genome
for (gene_name in fitmetadata$locus_tag) {
  if (startsWith(gene_name, "SM_") || startsWith(gene_name, "SMa")) {
    symbiotic_plasmid_count <- symbiotic_plasmid_count + 1
  } else if (startsWith(gene_name, "SMc")) {
    chromosome_count <- chromosome_count + 1
  }
}

LE_symcount <- 0
LE_chromcount <- 0

#count genes on each replicon for leading edge
for (gene_name in leadingEdge_allgenes$locus_tag) {
  if (startsWith(gene_name, "SM_") || startsWith(gene_name, "SMa")) {
    LE_symcount <- LE_symcount + 1
  } else if (startsWith(gene_name, "SMc")) {
    LE_chromcount <- LE_chromcount + 1
  }
}

#make table and test for significant group difference
replicon_table <- matrix(c(symbiotic_plasmid_count, chromosome_count, LE_symcount, LE_chromcount), nrow = 2, byrow = TRUE)
replicontest <- chisq.test(replicon_table)
replicontest
replicon_table


#make individual leading-edge subset tables

#bactamb

all_bactamb <- leadingEdge_extracted[["fgsea_bactamb_ES_leading"]]

#bactN

all_bactN <- unique(c(leadingEdge_extracted[["fgsea_bactN_ES_leading"]], leadingEdge_extracted[["KEGG_fgsea_bactN_ES_leading"]]))

#nodamb

all_nodamb <- leadingEdge_extracted[["fgsea_nodamb_ES_leading"]]

#nodN

all_ES_nodN <- unique(c(leadingEdge_extracted[["fgsea_nodN_ES_leading"]], leadingEdge_extracted[["KEGG_fgsea_nodN_ES_leading"]]))

all_NE_nodN <- leadingEdge_extracted[["KEGG_fgsea_nodN_NE_leading"]]

bact_commongenes <- intersect(all_bactamb, all_bactN)
bact_commongenes

nod_commongenes <- intersect(all_nodamb, all_ES_nodN)
nod_commongenes

unique_bactN <-  setdiff(setdiff(all_bactN, c(all_nodamb, all_ES_nodN)), all_bactamb)
unique_nodamb <- setdiff(setdiff(all_nodamb, all_bactN), all_ES_nodN)
unique_nodN <- setdiff(c(all_NE_nodN, all_ES_nodN), c(all_bactN, all_nodamb))


coresoilgenes <- intersect(all_bactN, intersect(all_nodamb, all_ES_nodN))

all_amb <- unique(c(all_bactamb, all_nodamb))

#pSym proportion for genes under selection at low N

symbiotic_amb_count <- 0
chrom_amb_count <- 0

for (gene_name in all_amb) {
  if (startsWith(gene_name, "SM_") || startsWith(gene_name, "SMa")) {
    symbiotic_amb_count <- symbiotic_amb_count + 1
  } else if (startsWith(gene_name, "SMc")) {
    chrom_amb_count <- chrom_amb_count + 1
  }
}

replicon_table_amb <- matrix(c(symbiotic_plasmid_count, chromosome_count, symbiotic_amb_count, chrom_amb_count), nrow = 2, byrow = TRUE)
replicontest_amb <- chisq.test(replicon_table_amb)

replicontest_amb
replicon_table_amb



all_N <- unique(c(all_bactN, all_ES_nodN, all_NE_nodN))

#pSym proportion for genes under selection at high N

symbiotic_N_count <- 0
chrom_N_count <- 0

for (gene_name in all_N) {
  if (startsWith(gene_name, "SM_") || startsWith(gene_name, "SMa")) {
    symbiotic_N_count <- symbiotic_N_count + 1
  } else if (startsWith(gene_name, "SMc")) {
    chrom_N_count <- chrom_N_count + 1
  }
}

replicon_table_N <- matrix(c(symbiotic_plasmid_count, chromosome_count, symbiotic_N_count, chrom_N_count), nrow = 2, byrow = TRUE)
replicontest_N <- chisq.test(replicon_table_N)

replicontest_N
replicon_table_N

#leading-edge genes present within and unique to each treatment/subpopulation condition


unique_amb <- setdiff(all_amb, intersect(all_amb, all_N))
unique_N <- setdiff(all_N, intersect(all_amb, all_N))


#bacteroid tables

bactamb_leadingEdge <- fitmetadata[fitmetadata$locus_tag %in% all_bactamb, ]
unique_bactN_table <- fitmetadata[fitmetadata$locus_tag %in% unique_bactN, ]

#note that there is no "bacteroid common genes" table because the bactamb subset is entirely contained within bactN, and therefore is the same as the common genes table

#nodule tables

nodamb_leadingEdge <- fitmetadata[fitmetadata$locus_tag %in% unique_nodamb, ]
nodN_leadingEdge <- fitmetadata[fitmetadata$locus_tag %in% unique_nodN, ]

#common genes table

coresoilgenes_table <- fitmetadata[fitmetadata$locus_tag %in% coresoilgenes, ]
coresoilgenes_table

#table for all_NE_nodN

nodN_NE_leadingEdge <- fitmetadata[fitmetadata$locus_tag %in% all_NE_nodN, ]

#these were then manually written to CSV files

```

```{r Chunk 13: Gene-level ANOVAs}

#gene-level type iii anova analysis

ANOVAcomplete <- COGcomplete

#remove t0 and extraneous info
ANOVAcomplete <- ANOVAcomplete[, -c(32:36)] 
ANOVAfitness <- ANOVAcomplete[, c(1, 19:31)]
anovastrata <- potlabels[-c(14:18)]
rownames(ANOVAfitness) <- ANOVAfitness$locus_tag
ANOVAfitness <- t(ANOVAfitness[, -c(1)])

#define treatment groups
ANOVAfitness <- data.frame(Ntreatment = c(rep("fertilized",3), rep("ambient",5),rep("fertilized", 3), rep("ambient", 2)), 
                            compartment = c(rep("nodule",8), rep("bacteroid",5)),
                            strata = anovastrata, ANOVAfitness)

#run gene-level anovas on each gene in the genome testing for effects of N treatment and subpopulation
anovafit_results <- new.env()

for (i in 4:ncol(ANOVAfitness)) { #start here to avoid metadata columns
    col_name <- colnames(ANOVAfitness)[i]
    formula <- as.formula(paste(col_name, "~ Ntreatment/compartment")) #anova formula
    anova_result <- Anova(lm(formula, data = ANOVAfitness), type = 'III') #runs anova
    assign(col_name, anova_result, envir = anovafit_results) #stores in results env
}

#remove intercept pval
for (obj_name in ls(anovafit_results)) {
    result <- anovafit_results[[obj_name]]
    anovafit_results[[obj_name]] <- result[-c(1, nrow(result)), ]
}

# Extract p-values for each factor separately
ntreatment_pvals <- unlist(lapply(anovafit_results, function(df) df["Ntreatment", "Pr(>F)"]))
compartment_pvals <- unlist(lapply(anovafit_results, function(df) df["compartment", "Pr(>F)"]))

# Perform FDR adjustment on each factor separately
adjusted_ntreatment_pvals <- p.adjust(ntreatment_pvals, method = "fdr")
adjusted_compartment_pvals <- p.adjust(compartment_pvals, method = "fdr")

# Update anovafit_results with adjusted p-values
for (obj_name in ls(anovafit_results)) {
    result <- anovafit_results[[obj_name]]
    result[result$Term == "Ntreatment", "Pr(>F)"] <- adjusted_ntreatment_pvals
    result[result$Term == "compartment", "Pr(>F)"] <- adjusted_compartment_pvals
    anovafit_results[[obj_name]] <- result
}

#pick out significant results from dataset
anovafit_significant <- new.env()
for (obj_name in ls(anovafit_results)) {
  result <- anovafit_results[[obj_name]] #goes through and picks out significant results

  if (any(result$"Pr(>F)"[1:2] < 0.2)) { #only retrieve qvals under the threshold for at least one factor
    assign(obj_name, result, envir = anovafit_significant)
  }
}


#get the names of objects in anovafit_significant
significant_genes <- ls(anovafit_significant)

#convert to character vector
significant_genes <- as.character(significant_genes)
significantanova_LE <- intersect(significant_genes, leadingEdge_allgenes[, 1])

#get info for significant genes
sig_anova_info <- COGcomplete[COGcomplete[, 1] %in% significant_genes, ]

#test overlap between significant individual genes and leading edge
LE_anova_overlap <- intersect(sig_anova_info$locus_tag, leadingEdge_allgenes$locus_tag)



# Create an empty data frame to store the significant LE data
significant_LE_data <- data.frame()

# Loop through each element of LE_anova_overlap
for (gene_id in LE_anova_overlap) {
  # Find the row in sig_anova_info that matches the gene_id
  matching_row <- sig_anova_info[sig_anova_info$locus_tag == gene_id, ]
  
  # If a match is found, append the row to significant_LE_data
  if (nrow(matching_row) > 0) {
    significant_LE_data <- rbind(significant_LE_data, matching_row)
  }
}

# Add the qval_N and qval_subp columns
significant_LE_data$qval_N <- NA
significant_LE_data$qval_subp <- NA

# Loop through each gene in LE_anova_overlap
for (gene_id in LE_anova_overlap) {
  # Find the corresponding list in anovafit_significant
  gene_list <- anovafit_significant[[gene_id]]
  
  # Find the row in significant_LE_data that matches the gene_id
  matching_row <- which(significant_LE_data$locus_tag == gene_id)
  
  # Extract the qvalues and assign them to the corresponding columns
  significant_LE_data$qval_N[matching_row] <- gene_list["Ntreatment", "Pr(>F)"]
  significant_LE_data$qval_subp[matching_row] <- gene_list["Ntreatment:compartment", "Pr(>F)"]
}

#get list of significant KEGG pathways to organize table

# Find all objects in the global environment starting with "KEGG_fgsea_"
all_fgsea_KEGG <- ls(envir = .GlobalEnv, pattern = "^KEGG_fgsea_")

# Create an empty character vector to store significant KEGG pathways
significant_KEGG_pathways <- character()

# Loop through each object in all_fgsea_KEGG
for (obj_name in all_fgsea_KEGG) {
  # Get the corresponding data frame from the global environment
  df <- get(obj_name, envir = .GlobalEnv)
  
  # Find rows where padj <= 0.2
  significant_rows <- df[df$padj <= 0.2, ]
  
  # Extract the "pathway" values from the significant rows
  significant_pathways <- significant_rows$pathway
  
  # Append the significant pathways to the vector
  significant_KEGG_pathways <- c(significant_KEGG_pathways, significant_pathways)
}

# Remove the first four characters from each element in significant_KEGG_pathways
significant_KEGG_pathways <- sub("^set_", "", significant_KEGG_pathways)

# Remove "mapXXXXX" IDs from the "KEGG_Pathway" column in significant_LE_data
significant_LE_data$KEGG_Pathway <- lapply(significant_LE_data$KEGG_Pathway, function(pathway) {
  pathway <- unlist(strsplit(pathway, ","))  # Split the pathway string by comma
  pathway <- trimws(pathway)  # Remove leading/trailing whitespace
  pathway <- pathway[grep("^ko", pathway)]  # Keep only IDs starting with "ko"
  pathway
})

# Remove KEGG IDs not present in significant_KEGG_pathways, but only if there are multiple IDs
significant_LE_data$KEGG_Pathway <- lapply(significant_LE_data$KEGG_Pathway, function(pathway) {
  if (length(pathway) > 1) {
    pathway <- pathway[pathway %in% significant_KEGG_pathways]  # Keep only IDs present in significant_KEGG_pathways
  }
  pathway
})

# Combine the remaining KEGG IDs back into a comma-separated string
significant_LE_data$KEGG_Pathway <- lapply(significant_LE_data$KEGG_Pathway, function(pathway) {
  if (length(pathway) == 0) {
    "-"  # Replace empty cells with a "-" character
  } else {
    paste(pathway, collapse = ",")
  }
})

significant_LE_data$KEGG_Pathway <- unlist(significant_LE_data$KEGG_Pathway, use.names = FALSE)
# write.csv(significant_LE_data, "C:/Users/User/Desktop/significant_LE_genes.csv", row.names = FALSE)

```

```{r Chunk 14: Tentative graveyard zone}

#here's all the deprecated code, which I'm keeping here both to show my work and in case anything is needed from here
# 
# #mulEA (evaluating to replace fgsea with this)
# 
# # Get a list of objects ending with "_ranks" in the global environment
# objects <- ls(pattern = "_ranks$", envir = .GlobalEnv)
# 
# # Create a new dataframe for each object with two columns
# for (obj_name in objects) {
#   vec <- get(obj_name, envir = .GlobalEnv)
#   df_name <- paste0(obj_name, "_mulea")
#   assign(df_name, data.frame(names = names(vec), x = vec))
# }
# 
# 
# # Install mulea package if not already installed
# 
# library(devtools)
# # install_github("https://github.com/koralgooll/MulEA.git", force = TRUE)
# require(MulEA)
# 
# # Load KEGG pathway gene set collection
# mulea_keggES <- read_gmt("KEGGsets_ES.gmt")
# mulea_keggNE <- read_gmt("KEGGsets_NE.gmt")
# 
# # Run mulea analysis
# 
# 
# #nodule
# 
# #+N ES
# mulea_N_ES_nod <- gsea(gmt = mulea_keggES,
#                    element_names = nodN_ranks_mulea$names,
#                    element_scores = nodN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_ES_nod_results <- run_test(mulea_N_ES_nod)
# 
# #--N ES
# mulea_amb_ES_nod <- gsea(gmt = mulea_keggES,
#                    element_names = nodamb_ranks_mulea$names,
#                    element_scores = nodamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_ES_nod_results <- run_test(mulea_amb_ES_nod)
# 
# 
# #+N NE
# mulea_N_NE_nod <- gsea(gmt = mulea_keggNE,
#                    element_names = nodN_ranks_mulea$names,
#                    element_scores = nodN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_NE_nod_results <- run_test(mulea_N_NE_nod)
# 
# 
# #--N NE
# mulea_amb_NE_nod <- gsea(gmt = mulea_keggNE,
#                    element_names = nodamb_ranks_mulea$names,
#                    element_scores = nodamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_NE_nod_results <- run_test(mulea_amb_NE_nod)
# 
# 
# 
# #bacteroid
# 
# #+N ES
# mulea_N_ES_bact <- gsea(gmt = mulea_keggES,
#                    element_names = bactN_ranks_mulea$names,
#                    element_scores = bactN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_ES_bact_results <- run_test(mulea_N_ES_bact)
# 
# #--N ES
# mulea_amb_ES_bact <- gsea(gmt = mulea_keggES,
#                    element_names = bactamb_ranks_mulea$names,
#                    element_scores = bactamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_ES_bact_results <- run_test(mulea_amb_ES_bact)
# 
# 
# #+N NE
# mulea_N_NE_bact <- gsea(gmt = mulea_keggNE,
#                    element_names = bactN_ranks_mulea$names,
#                    element_scores = bactN_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_N_NE_bact_results <- run_test(mulea_N_NE_bact)
# 
# 
# #--N NE
# mulea_amb_NE_bact <- gsea(gmt = mulea_keggNE,
#                    element_names = bactamb_ranks_mulea$names,
#                    element_scores = bactamb_ranks_mulea$x,
#                    number_of_permutations = 10000)
# mulea_amb_NE_bact_results <- run_test(mulea_amb_NE_bact)



# NOTE: decided to go with fitness ranking analysis exclusively; leaving this code in for documentation purposes and in case we need to give it a second look. This creates true rank-abundance curves based on the raw counts data rather than fitness ranking curves based off fitness ratios

# RAC <- function(x = ""){
#   x = as.vector(x)
#   x.ab = x[x > 0]
#   x.ab.ranked = x.ab[order(x.ab, decreasing = TRUE)]
#   return(x.ab.ranked)
# } #returns a rank-abundance dataset for a given site to be plotted
# 
# RACdata <- RACsubsetter %>%
#   group_by(group) %>%
#   summarise(across(starts_with("SM"), mean)) #averages each treatment together and produces a table listing mean counts
# 
# RACdata <- as.data.frame(RACdata)
# row.names(RACdata) <- RACdata[,1]
# RACdata <- RACdata[,-1] #cleans up dataframe so it can be unlisted and plotted
# 
# colnames(RACdata) <- substr(colnames(RACdata), 0, 9)
# RACnames <- grep("^SMa", colnames(RACdata))
# colnames(RACdata)[RACnames] <- substr((colnames(RACdata))[RACnames], 0, 7)
# trueRACnames <- grep("^SMc", colnames(RACdata)) 
# colnames(RACdata)[trueRACnames] <- gsub("\\s+$", "", colnames(RACdata)[trueRACnames]) #ensures column names are exactly the same as the ones in Nmetabolism for matching genes of interest
# 
# RACdata_Nmetabolism <- RACdata[, intersect(colnames(RACdata), Nmetabolism$V1)] #similar code from elsewhere wasn't working, so I asked chatGPT to suggest a new method and it gave me the intersect() syntax within this
# 
# RACdata_nodNE <- RACdata[, intersect(colnames(RACdata), colnames(nodNEfit))]
# RACdata_nodES <- RACdata[, intersect(colnames(RACdata), colnames(nodESfit))]
# 
# #RACs for whole genomes
# bactambRAC <- unlist(RACdata[1,])
# bactfertRAC <- unlist(RACdata[2,])
# nodambRAC <- unlist(RACdata[3,])
# nodfertRAC <- unlist(RACdata[4,])
# t0RAC <- unlist(RACdata[5,]) #converts rows to proper format for RAC analysis and plotting
# 
# RAC_bactamb <- RAC(bactambRAC)
# RAC_bactfert <- RAC(bactfertRAC)
# RAC_nodamb <- RAC(nodambRAC)
# RAC_nodfert <- RAC(nodfertRAC)
# RAC_t0 <- RAC(t0RAC)
# 
# #RACs for N metabolism genes
# Nmetab_bactambRAC <- unlist(RACdata_Nmetabolism[1,])
# Nmetab_bactfertRAC <- unlist(RACdata_Nmetabolism[2,])
# Nmetab_nodambRAC <- unlist(RACdata_Nmetabolism[3,])
# Nmetab_nodfertRAC <- unlist(RACdata_Nmetabolism[4,])
# Nmetab_t0RAC <- unlist(RACdata_Nmetabolism[5,])
# 
# RAC_Nmetab_bactamb <- RAC(Nmetab_bactambRAC)
# RAC_Nmetab_bactfert <- RAC(Nmetab_bactfertRAC)
# RAC_Nmetab_nodamb <- RAC(Nmetab_nodambRAC)
# RAC_Nmetab_nodfert <- RAC(Nmetab_nodfertRAC)
# RAC_Nmetab_t0 <- RAC(Nmetab_t0RAC)
# 
# finalRACdata_Nmetabolism <- as.data.frame(rbind(RAC_Nmetab_bactamb, RAC_Nmetab_bactfert, RAC_Nmetab_nodamb, RAC_Nmetab_nodfert, RAC_Nmetab_t0))
# colnames(finalRACdata_Nmetabolism) <- 1:29
# 
# #RACs for nodulation ES and NE genes
# 
# #NE
# nodNE_bactambRAC <- unlist(RACdata_nodNE[1,])
# nodNE_bactfertRAC <- unlist(RACdata_nodNE[2,])
# nodNE_nodambRAC <- unlist(RACdata_nodNE[3,])
# nodNE_nodfertRAC <- unlist(RACdata_nodNE[4,])
# nodNE_t0RAC <- unlist(RACdata_nodNE[5,])
# 
# RAC_nodNE_bactamb <- RAC(nodNE_bactambRAC)
# RAC_nodNE_bactfert <- RAC(nodNE_bactfertRAC)
# RAC_nodNE_nodamb <- RAC(nodNE_nodambRAC)
# RAC_nodNE_nodfert <- RAC(nodNE_nodfertRAC)
# RAC_nodNE_t0 <- RAC(nodNE_t0RAC)
# 
# finalRACdata_nodNE <- as.data.frame(rbind(RAC_nodNE_bactamb, RAC_nodNE_bactfert, RAC_nodNE_nodamb, RAC_nodNE_nodfert, RAC_nodNE_t0))
# colnames(finalRACdata_nodNE) <- 1:4145
# 
# #ES
# nodES_bactambRAC <- unlist(RACdata_nodES[1,])
# nodES_bactfertRAC <- unlist(RACdata_nodES[2,])
# nodES_nodambRAC <- unlist(RACdata_nodES[3,])
# nodES_nodfertRAC <- unlist(RACdata_nodES[4,])
# nodES_t0RAC <- unlist(RACdata_nodES[5,])
# 
# RAC_nodES_bactamb <- RAC(nodES_bactambRAC)
# RAC_nodES_bactfert <- RAC(nodES_bactfertRAC)
# RAC_nodES_nodamb <- RAC(nodES_nodambRAC)
# RAC_nodES_nodfert <- RAC(nodES_nodfertRAC)
# RAC_nodES_t0 <- RAC(nodES_t0RAC)
# 
# finalRACdata_nodES <- as.data.frame(rbind(RAC_nodES_bactamb, RAC_nodES_bactfert, RAC_nodES_nodamb, RAC_nodES_nodfert, RAC_nodES_t0))
# colnames(finalRACdata_nodES) <- 1:832
# 
# #Kolmogorov-Smirnov tests to determine if rank-abundance curves are significantly different between treatments; WHOLE-GENOME SET
# 
# ks_bacteroid <- ks.test(RAC_bactamb, RAC_bactfert, exact = TRUE) #bacteroid treatment, -N vs +N
# ks_nodule <- ks.test(RAC_nodamb, RAC_nodfert, exact = TRUE) #undiff nodule treatment, -N vs +N
# 
# ks_amb_compartment <- ks.test(RAC_nodamb, RAC_bactamb, exact = TRUE) #Bacteroid  vs undiff nodule at -N
# ks_fert_compartment <- ks.test(RAC_bactfert, RAC_nodfert, exact = TRUE) #B vs undiff n at +N
# 
# #K-S N METABOLISM
# 
# ks_bacteroid_Nmetab <- ks.test(RAC_Nmetab_bactamb, RAC_Nmetab_bactfert, exact = TRUE) 
# ks_nodule_Nmetab <- ks.test(RAC_Nmetab_nodamb, RAC_Nmetab_nodfert, exact = TRUE)
# 
# ks_amb_compartment_Nmetab <- ks.test(RAC_Nmetab_nodamb, RAC_Nmetab_bactamb, exact = TRUE)
# ks_fert_compartment_Nmetab <- ks.test(RAC_Nmetab_bactfert, RAC_Nmetab_nodfert, exact = TRUE)
# 
# #K-S NODULATION NONESSENTIAL/ESSENTIAL
# 
# ks_bacteroid_nodNE <- ks.test(RAC_nodNE_bactamb, RAC_nodNE_bactfert, exact = TRUE) 
# ks_nodule_nodNE <- ks.test(RAC_nodNE_nodamb, RAC_nodNE_nodfert, exact = TRUE)
# 
# ks_amb_nodNE <- ks.test(RAC_nodNE_nodamb, RAC_nodES_bactamb, exact = TRUE)
# ks_fert_nodNE <- ks.test(RAC_nodNE_nodfert, RAC_nodNE_bactfert, exact = TRUE)
# 
# ks_bacteroid_nodES <- ks.test(RAC_nodES_bactamb, RAC_nodES_bactfert, exact = TRUE)
# ks_nodule_nodES <- ks.test(RAC_nodES_nodamb, RAC_nodES_nodfert, exact = TRUE)
# 
# ks_amb_nodES <- ks.test(RAC_nodES_nodamb, RAC_nodES_bactamb, exact = TRUE)
# ks_fert_nodES <- ks.test(RAC_nodES_nodfert, RAC_nodES_bactfert, exact = TRUE)

# # simple curve plots of the RACs
# 
# all_RACs <- ls(pattern = "^RAC_") #make a list with all 20 RACs
# 
# for (i in 1:length(all_RACs)) {
#   plot.new()
#   ranks <- as.vector(seq(1, length(get(all_RACs[i]))))
#   opar <- par(no.readonly = TRUE)
#   par(mar = c(5.1, 5.1, 4.1, 2.1))
#   plot(ranks, log(get(all_RACs[i])), type = 'p', axes = F,
#        xlab = "Rank in abundance", ylab = "Abundance",
#        las = 1, cex.lab = 1.4, cex.axis = 1.25)
#   
#   box()
#   axis(side = 1, labels = T, cex.axis = 1.25)
#   axis(side = 2, las = 1, cex.axis = 1.25,
#        labels = c(1, 100, 10000, 100000, 1000000), at = log(c(1, 100, 10000, 100000, 1000000)))
#   
#   mtext(all_RACs[i], side = 3, line = 1, cex = 1.5)
# } #This for loop calls the above plot code on all 20 RAC names listed within all_RACs, producing 20 rank-abundance curves
# 
# #ggplot violin plots of RAC data
# 
# for (i in 1:length(all_RACs)) {
#   
#   p <- ggplot(data.frame(x = 1:length(get(all_RACs[[i]])), 
#                           y = get(all_RACs[[i]])), 
#               aes(x = "", y = y)) +
#     geom_violin(fill = "gray", alpha = 0.8) + #violin plot
#     geom_jitter(color = "black", size = 1.5, alpha = 0.4) + #point layer
#     xlab("") +
#     ylab("Abundance") +
#     ggtitle(all_RACs[[i]]) + #title by variable name
#     theme_classic() #need to tweak theme to make it look better/cleaner
#   print(p)
# }

#example code for plotting RACs together on the same axis; the ranks need some fixing
# 
# finalRACdata_complete <- as.data.frame(rbind(RAC_bactamb, RAC_bactfert, RAC_nodamb, RAC_nodfert, RAC_t0))
# colnames(finalRACdata_complete) <- 1:5175
# finalRACdata_complete$treatment <- row.names(finalRACdata_complete)
# 
# finalRACdata_complete <- pivot_longer(finalRACdata_complete, cols = colnames(finalRACdata_complete)[1:5175])
# 
# combinedRAC_complete <- ggplot(finalRACdata_complete, aes(x = as.numeric(as.character(name)), y = log10(value), group = treatment, color = treatment, fill = treatment)) +
#   geom_line()
# 
# combinedRAC_complete


# #CMH TESTS organizing data
# 
# CMHstrata <- potlabels[-c(14:18)]
# CMHpots <- c("_nf", "_nf", "_nf", "_na", "_na", "_na", "_na", "_na", "_bf", "_bf", "_bf", "_ba", "_ba")
# CMHstratanames <- paste(CMHstrata, CMHpots, sep = "") #sets of ids to identify strata and individual dataset names
# CMH_env <- new.env() #new env to store CMH tables
# for (df_name in COGnames) {
#   df <- get(df_name)
#   essential_pos <- vector("integer", length = 13)
#   essential_neg <- vector("integer", length = 13)
#   essential_neu <- vector("integer", length = 13)
#   N_pos <- vector("integer", length = 13)
#   N_neg <- vector("integer", length = 13)
#   N_neu <- vector("integer", length = 13) #empty lists to store results
# 
#   for (i in 2:14) {
#     essential_pos[i] <- sum(df$essentiality == "essential" & df[[i]] == 1)
#     essential_neg[i] <- sum(df$essentiality == "essential" & df[[i]] == -1)
#     essential_neu[i] <- sum(df$essentiality == "essential" & df[[i]] == 0)
# 
#     N_pos[i] <- sum(df$essentiality == "N" & df[[i]] == 1)
#     N_neg[i] <- sum(df$essentiality == "N" & df[[i]] == -1)
#     N_neu[i] <- sum(df$essentiality == "N" & df[[i]] == 0) #count pos, neu, neg for each essentiality category
#   }
#     df_output <- data.frame(
#     essential_pos = essential_pos,
#     essential_neg = essential_neg,
#     essential_neu = essential_neu,
#     N_pos = N_pos,
#     N_neg = N_neg,
#     N_neu = N_neu
#   ) %>%
#       t() %>%
#       .[, -1] #transpose and delete column of zeroes (don't know why for(i in 2:14) doesn't get rid of the zero col?)
#     #creates output df with 13 data columns and 6 rows for categorical totals
#   colnames(df_output) <- CMHstratanames
#   output_name <- paste0("CMH_", df_name)
#   assign(output_name, df_output, envir = CMH_env)
# } #names CMH_COG_X to CMH environment
# 
# 
# #make tables for CMH tests
# 
# output_dfs <- list() # empty list to store finished tables
# for (df_name in ls(envir = CMH_env, pattern = "CMH_COG_")) {
#   df <- get(df_name, envir = CMH_env) #iterate through all COG dfs in CMH_env
#     cog_id <- substr(df_name, nchar(df_name) - 4, nchar(df_name)) #retrieve cog ID from df name
# 
#   row_names <- c("essential_pos", "essential_neg", "essential_neu", "N_pos", "N_neg", "N_neu") #input df row names
# 
#   for (col_name in colnames(df)) {
#     positive_table <- matrix(
#       c(df[row_names[1], col_name], df[row_names[3], col_name], df[row_names[4], col_name], df[row_names[6], col_name]),
#       nrow = 2,
#       dimnames = list(c("essential", "N"), c("positive", "neutral"))
#     ) #create positive contingency table
#     positive_df <- data.frame(essentiality = c("essential", "N"),
#                               positive = positive_table[1, ],
#                               neutral = positive_table[2, ])
#     output_name_positive <- paste0("CMH_", cog_id, "_", col_name, "_positive")
#     output_dfs[[output_name_positive]] <- positive_df #grabs data for positive tables and adds to corresponding empty table
# 
#     negative_table <- matrix(
#       c(df[row_names[2], col_name], df[row_names[3], col_name], df[row_names[5], col_name], df[row_names[6], col_name]),
#       nrow = 2,
#       dimnames = list(c("essential", "N"), c("negative", "neutral"))
#     )
#     negative_df <- data.frame(essentiality = c("essential", "N"),
#                               negative = negative_table[1, ],
#                               neutral = negative_table[2, ])
#     output_name_negative <- paste0("CMH_", cog_id, "_", col_name, "_negative")
#     output_dfs[[output_name_negative]] <- negative_df #ditto for the negative tables
#   }
# }
# 
# for (df_name in names(output_dfs)) {
#   df <- output_dfs[[df_name]]
#     row.names(df) <- df$essentiality
#     df <- df[, -1]
#     output_dfs[[df_name]] <- df
# } #clean up outputs to replace row names with third names column and delete, leaving only 2x2 table
# list2env(output_dfs, envir = CMH_env) #store in CMH_env
# 
# partitioned_CMHenv <- new.env() #new env to store subsets
# CMH_partitions <- ls(CMH_env) #list out all the objects we're working on
# CMH_cogs <- substring(CMH_partitions, 9, 9) #extract COG index for each item
# CMH_unique_cogs <- unique(CMH_cogs) #get list of unique COGs
# 
# for(cog in CMH_unique_cogs) {
#   unique_cog <- CMH_partitions[CMH_cogs == cog] #iterate through unique COG list and pull out all objects in CMH_cogs which match the current unique COG in the list
#   partition_name <- paste0("CMH_", cog, "_env") #name output env according to COG at hand
#   new_partition_env <- new.env() #create env
#   for(cogname in unique_cog){
#     new_partition_env[[cogname]] <- CMH_env[[cogname]] #puts objects of that cogname from CMH_env into new env
#   }
#   partitioned_CMHenv[[partition_name]] <- new_partition_env #assigns env at hand to master list of partitioned envs, bearing the partition_name at hand in this iteration
# }
# 
# for(env_name in ls(partitioned_CMHenv)) {
#   partition <- partitioned_CMHenv[[env_name]]
#   cog_names <- ls(partition)
#   removed <- cog_names[nchar(cog_names) == 9]
#   rm(list = removed, envir = partition)
# } #remove CMH envs containing raw data from building the tables
# 
# 
# 
# sample_names <- unique(substr(ls(partitioned_CMHenv)[[1]], 11, 14)) #get unique 4-char id from each site name
# positive_CMH_results <- list()
# negative_CMH_results <- list() #separate lists for pos and neg results
# 
# 
# for (cog_group_name in ls(partitioned_CMHenv)) {
#   cog_group_env <- partitioned_CMHenv[[cog_group_name]]  #get the listed data from each COG group in the env
#   
#   positive_array <- array(dim = c(2, 2, 13, length(sample_names)))
#   negative_array <- array(dim = c(2, 2, 13, length(sample_names))) #separate arrays for pos and neg comparisons
# 
#   for (table_name in ls(cog_group_env)) { #inner loop goes through each table in the current COG group
#     unique_id <- substr(table_name, 11, 14)
#     table_idx <- which(sample_names == unique_id) #get the index of the object from sample_names to keep track of where the id came from
#     
#   target_array <- if (grepl("positive", table_name)) {
#     positive_array
#   } else {
#     negative_array
#   } #separate based on pos/neg comparison
#     
#     target_array[, , , table_idx] <- cog_group_env[[table_name]] #assign tabel at hand to correct array
#   }
# 
#   positive_CMH_result <- mantelhaen.test(positive_array)
#   negative_CMH_result <- mantelhaen.test(negative_array) #run CMH tests
# 
#   positive_CMH_results[[paste0("CMH_", cog_group_name, "_positive")]] <- positive_CMH_result
#   negative_CMH_results[[paste0("CMH_", cog_group_name, "_negative")]] <- negative_CMH_result #store results
# }
# 
# 



#commented code is for duplicating kegg ko ids to run functional analysis. I decided to use pathway ids only so this is deprecated 

# newtags_modified <- newtags #save duplicate in case something gets messed up while coding
# 
# for (i in 1:nrow(newtags_modified)) {
#   kegg_ko <- newtags_modified[i, "KEGG_ko"]
#   if (!is.na(kegg_ko) && grepl(",", kegg_ko)) {
#     kegg_ids <- unlist(strsplit(kegg_ko, ",")) #splits entries with multiple KEGG KOs by the comma separator
#     for (id in kegg_ids) {
#       new_row <- newtags_modified[i, ]
#       new_row["KEGG_ko"] <- trimws(id) #creates duplicate rows and adds new KEGG id
#       newtags_modified <- rbind(newtags_modified, new_row)
#     }
#     newtags_modified <- newtags_modified[-i, ] #gets rid of original KEGG id row with unsplit entries
#     i <- i - 1  #adjust the index to account for removed row
#   }
# }
# row.names(newtags_modified) <- NULL #fixes weird row names created by this procedure

#old contingency table code

# contingency_tables <- list() #creates empty list to store conting tables 
# 
# for (name in COGnames) {
#   df <- get(name)
#   treatment_cols <- c(19:21, 22:26, 27:29, 30:31)
#   treatment_names <- c("nod +N", "nod -N", "bact +N", "bact -N")
#   if (length(treatment_names) != length(treatment_cols)) {
#     treatment_names <- rep(treatment_names, length.out = length(treatment_cols))
#   }  #defines ranges to be summed together to pool each treatment for conting tables, and corrects length 
#   num_treatments <- length(treatment_cols)
#   contingency_table <- matrix(0, nrow = 3, ncol = num_treatments,
#                               dimnames = list(c("decreasing", "neutral", "increasing"), treatment_names)) #creates table objects
#   
#   for (i in 1:num_treatments) {
#     treatment_col <- df[[treatment_cols[i]]]
#     counts <- table(factor(treatment_col, levels = c(-1, 0, 1)))
#     contingency_table[, i] <- counts
#   } #adds count labels to table objects
#   contingency_tables[[name]] <- contingency_table
# }
# 
# for (name in names(contingency_tables)) {
#   table_name <- paste0(name, "_table")
#   assign(table_name, unlist(contingency_tables[[name]]))
# } #names tables according to the COG they represent
# 
# all_dfs <- ls(globalenv())
# COGtables <- grep("^COG_.*_table$", ls(), value = TRUE)
# 
# for (i in seq_along(COGtables)) {
#   df_name <- COGtables[i]
#   df <- get(df_name)
#   column_ranges <- list(c(1:3), c(4:8), c(9:11), c(12:13))
#   merged_df <- data.frame(matrix(0, nrow = nrow(df), ncol = length(column_ranges)))
#   rownames(merged_df) <- rownames(df)
#   
#   for (j in seq_along(column_ranges)) {
#     columns <- column_ranges[[j]]
#     merged_df[, j] <- rowSums(df[, columns, drop = FALSE])
#   }
#   assign(df_name, merged_df, envir = globalenv())
#} #tabulates contingency data for each COG table


# some old KEGG code here that I don't want to get rid of in case I want to reuse parts of it

# create subsets by essentiality for symbiosis
# KEGGfitmetadata_ES <- subset(KEGGfitmetadata, essentiality == "essential")
# KEGGfitmetadata_NE <- subset(KEGGfitmetadata, essentiality == "N")
# KEGGfitmetadata_ES <- KEGGfitmetadata_ES[, -c(3)]
# KEGGfitmetadata_NE <- KEGGfitmetadata_NE[, -c(3)] 
# 
# KEGGfitmetadata_ES$KEGG_Pathway <- trimws(KEGGfitmetadata_ES$KEGG_Pathway)
# KEGGfitmetadata_NE$KEGG_Pathway <- trimws(KEGGfitmetadata_NE$KEGG_Pathway)
# KEGGfitmetadata_ES$KEGG_Pathway <- as.character(KEGGfitmetadata_ES$KEGG_Pathway)
# KEGGfitmetadata_NE$KEGG_Pathway <- as.character(KEGGfitmetadata_NE$KEGG_Pathway) #apparently have to do this to get strsplit() to work
# 
# #list names of unique pathway ids for making contingency tables downstream
# KEGGtablenames_ES <- character() #create vector of contingency table names
# for (i in seq_len(nrow(KEGGfitmetadata_ES))) {
#   pathway_ids <- unlist(strsplit(KEGGfitmetadata_ES[["KEGG_Pathway"]][i], ",")) #unlist current cell in KEGG_Pathway by , separator
#   for (pathway_id in pathway_ids) {
#     pathway_id <- trimws(pathway_id)
#     if (grepl("^ko\\d{5}$", pathway_id) && !pathway_id %in% KEGGtablenames_ES) {
#       KEGGtablenames_ES <- c(KEGGtablenames_ES, pathway_id) #if KEGG id starts with ko and is followed by 5 numbers, and this particular one isn't already added to KEGGtablenames, then add it
#     }
#   }
# }
# 
# KEGGtablenames_NE <- character() 
# for (i in seq_len(nrow(KEGGfitmetadata_NE))) {
#   pathway_ids <- unlist(strsplit(KEGGfitmetadata_NE[["KEGG_Pathway"]][i], ","))
#   for (pathway_id in pathway_ids) {
#     pathway_id <- trimws(pathway_id) 
#     if (grepl("^ko\\d{5}$", pathway_id) && !pathway_id %in% KEGGtablenames_NE) {
#       KEGGtablenames_NE <- c(KEGGtablenames_NE, pathway_id)
#     }
#   }
# }
# 
# expanded_rows_ES <- data.frame(KEGG_Pathway = character(), stringsAsFactors = FALSE)
# expanded_rows_NE <- data.frame(KEGG_Pathway = character(), stringsAsFactors = FALSE) #make aux dfs to work with inside the loops
# 
# 
# for (i in seq_len(nrow(KEGGfitmetadata_ES))) {
#   pathway_ids <- unlist(strsplit(as.character(KEGGfitmetadata_ES[i, "KEGG_Pathway"]), ",")) #split pathway id cells
#   pathway_ids <- pathway_ids[!grepl("^map\\d{5}$", pathway_ids)] #get rid of map ids
#   
#   for (pathway_id in pathway_ids) {
#     new_row <- KEGGfitmetadata_ES[i, ]
#     new_row[["KEGG_Pathway"]] <- trimws(pathway_id) #duplicate rows containing multiple pathway ids
#     expanded_rows_ES <- rbind(expanded_rows_ES, new_row) #add duplicate row to recipient df
#   }
# } #expand and duplicate by pathway id as in COG analysis
# 
# for (i in seq_len(nrow(KEGGfitmetadata_NE))) {
#   pathway_ids <- unlist(strsplit(as.character(KEGGfitmetadata_NE[i, "KEGG_Pathway"]), ","))
#   pathway_ids <- pathway_ids[!grepl("^map\\d{5}$", pathway_ids)]
#   
#   for (pathway_id in pathway_ids) {
#     new_row <- KEGGfitmetadata_NE[i, ]
#     new_row[["KEGG_Pathway"]] <- trimws(pathway_id)
#     expanded_rows_NE <- rbind(expanded_rows_NE, new_row)
#   }
# }  #expand and duplicate by pathway id as in COG analysis
# 
# KEGGfitmetadata_ES <- expanded_rows_ES[complete.cases(expanded_rows_ES), , drop = FALSE]
# KEGGfitmetadata_NE <- expanded_rows_NE[complete.cases(expanded_rows_NE), , drop = FALSE] #removes rows with NAs

# #old turnover stuff--going to do Whitaker's
# 
# library(betapart)
# 
# # fitness values can't be directly analyzed using bray-curtis or jaccard
# 
# fit_turnoverdat <- ifelse(completefit <= -1, -1, ifelse(completefit >= 1, 1, 0)) #replace fitness values with 1, 0, or -1 depending on value (pos/neu/neg)
# fit_turnoverdat <- as.data.frame(fit_turnoverdat[1:(nrow(fit_turnoverdat) - 5),])
# fit_turnoverdat <- cbind(group = c("fert", "fert", "fert", "amb", "amb", "amb", "amb", "amb", "fert", "fert", "fert", "amb", "amb"), fit_turnoverdat)
# 
# shared_cols_ES <- intersect(names(as.data.frame(nodESfit)), names(fit_turnoverdat))
# shared_cols_NE <- intersect(names(as.data.frame(nodNEfit)), names(fit_turnoverdat)) #extract cols from ES and NE which are found in input data
# fit_turnover_ES <- fit_turnoverdat[, c("group", shared_cols_ES)]
# fit_turnover_NE <- fit_turnoverdat[, c("group", shared_cols_NE)] #subsets based on intersection
# 
# 
# fert_zero_counts_ES <- rowSums(fit_turnover_ES[fit_turnover_ES$group == "fert", -1] == 0)
# amb_zero_counts_ES <- rowSums(fit_turnover_ES[fit_turnover_ES$group == "amb", -1] == 0)
# fert_minus_one_ones_ES <- apply(fit_turnover_ES[fit_turnover_ES$group == "fert", -1], 1, function(row) sum(row %in% c(-1, 1)))
# amb_minus_one_ones_ES <- apply(fit_turnover_ES[fit_turnover_ES$group == "amb", -1], 1, function(row) sum(row %in% c(-1, 1))) #calc # of each category for ES
# fert_zero_counts_NE <- rowSums(fit_turnover_NE[fit_turnover_NE$group == "fert", -1] == 0)
# amb_zero_counts_NE <- rowSums(fit_turnover_NE[fit_turnover_NE$group == "amb", -1] == 0)
# fert_minus_one_ones_NE <- apply(fit_turnover_NE[fit_turnover_NE$group == "fert", -1], 1, function(row) sum(row %in% c(-1, 1)))
# amb_minus_one_ones_NE <- apply(fit_turnover_NE[fit_turnover_NE$group == "amb", -1], 1, function(row) sum(row %in% c(-1, 1))) # for NE
# 
# fertzeromean_ES <- mean(fert_zero_counts_ES)
# ambzeromean_ES <- mean(amb_zero_counts_ES)
# fertonesmean_ES <- mean(fert_minus_one_ones_ES)
# ambonesmean_ES <- mean(amb_minus_one_ones_ES)
# fertzeromean_NE <- mean(fert_zero_counts_NE)
# ambzeromean_NE <- mean(amb_zero_counts_NE)
# fertonesmean_NE <- mean(fert_minus_one_ones_NE)
# ambonesmean_NE <- mean(amb_minus_one_ones_NE) #mean counts
# 
# contingency_selection_ES <- matrix(c(fertzeromean_ES, fertonesmean_ES,
#                                      ambzeromean_ES, ambonesmean_ES),
#                                    nrow = 2, byrow = TRUE)
# contingency_selection_NE <- matrix(c(fertzeromean_NE, fertonesmean_NE,
#                                      ambzeromean_NE, ambonesmean_NE),
#                                    nrow = 2, byrow = TRUE) #make 2x2 tables comparing pos/neu and neu/neg
# 
# dimnames(contingency_selection_ES) <- list(c("fert", "amb"), c("0", "-1/1"))
# dimnames(contingency_selection_NE) <- list(c("fert", "amb"), c("0", "-1/1")) #assign names
# 
# test_underselection_ES <- chisq.test(contingency_selection_ES)
# test_underselection_NE <- chisq.test(contingency_selection_NE) #chisq tests of significant turnover by N treatment
#
# 
# fit_turnover_forjaccard <- as.data.frame(ifelse(fit_turnoverdat <= 0, 0, 1))
# 
# turnover_permanova <- adonis2(fit_turnover_forjaccard ~ finalmetadata$Ntreatment/finalmetadata$compartment + finalmetadata$newID, data = fit_turnover_forjaccard, permutations = 9999, method="jaccard")
# 
# turnover_permanova

#omnibus fgsea tests; no significant results when averaging across treatments

#make pathways file

# COGlist_omnibus <- lapply(unique(COGmatrices$COG), function(currCOG) {
#   COG_X_omnibus <- COGmatrices %>%
#     filter(COG == currCOG)
# 
#   return(COG_X_omnibus)
# })
# 
# for (i in seq_along(COGlist_omnibus)) {
#   currCOG <- unique(COGlist_omnibus[[i]]$COG)
#   assign(paste0("COG_", currCOG, "_omnibus"), COGlist_omnibus[[i]])
# }
# 
# 
# genesetsCOG_omnibus <- lapply(seq_along(COGlist_omnibus), function(i) {
#   df <- COGlist_omnibus[[i]]
#   first_col <- as.character(df[[1]])
#   vector_name <- paste0("set", unique(df[[4]]))
#   names(first_col) <- NULL
#   names <- setNames(list(first_col), vector_name)
#   return(names)
# })
# genesetsCOG_omnibus <- unlist(genesetsCOG_omnibus, recursive = FALSE)
# 
# 
# writeGmtPathways(genesetsCOG_omnibus, tempfile("COGsets_omnibus", fileext = ".gmt"))
# 
# 
# pathways_omnibus <- gmtPathways("COGsets_omnibus.gmt")
# 
# #make rankings file
# 
# tlike_data_omnibus <- data.frame(tval = apply(tlike_data_meaned, 1, mean))
# 
# tlike_meaned_omnibus <- unlist(tlike_data_omnibus[,1])
# 
# names(tlike_meaned_omnibus) <- rownames(tlike_data_omnibus)
# 
# tlike_omnibus_ranked <- rankfit(tlike_meaned_omnibus)
# 
# tlike_omnibus_ranked <- tlike_omnibus_ranked[order(-tlike_omnibus_ranked$x),,drop=FALSE]
# 
# write.table(tlike_omnibus_ranked, file = "C:/Users/User/Desktop/omnibus_ranked.rnk", sep = "\t", quote = FALSE, row.names = TRUE)
# 
# omnibus_ranks <- read.table("C:/Users/User/Desktop/omnibus_ranked.rnk", header=TRUE, colClasses = c("character", "numeric"))
# 
# omnibus_ranks_final <- as.numeric(unlist(omnibus_ranks$x))
# names(omnibus_ranks_final) <- rownames(omnibus_ranks)
# 
# #run fgsea
# 
# fgsea_omnibus_cog <- fgsea(pathways_omnibus, omnibus_ranks_final, minSize = 1, maxSize = 1100)


#old code for extracting gene-level info from fgsea--deprecated because it didn't actually make sense

# #extract gene-level info from significant sets for both fgsea analyses
# 
# library(tidyr) #get unnest function
# 
# all_fgsea_cog <- ls(pattern = "fgsea", envir = globalenv()) #find all fgsea results
# 
# #function which extracts necessary info from each result set and builds df
# process_fgsea_results <- function(fgsea_results, uniqueID) {
#   unnested <- unnest(fgsea_results, leadingEdge) #get leading edge list from each row
# 
#   pathway <- unnested$pathway
#   gene_names <- unnested$leadingEdge
#   n_genes <- nrow(unnested) #get the pathway and gene info
#   
#   enrichment_scores <- rep(fgsea_results$NES, times = n_genes)
#   padj_values <- rep(fgsea_results$padj, times = n_genes) #adds padj, NES score for gene set to each gene
#   
#   result_df <- data.frame(
#     pathway = pathway,
#     gene_name = gene_names,
#     normed_ES_score = enrichment_scores,
#     padj = padj_values
#   ) #df to store results
#   
#   result_df$uniqueID <- uniqueID
#   return(result_df)
# }
# 
# output_data <- list() #store fgsea results that pass the tests here, so that they can be run through process_fgsea_results
# 
# for (fgsea_var in all_fgsea_cog) {
#   fgsea_object <- get(fgsea_var, envir = globalenv())
#   
#   fgsea_filtered <- subset(fgsea_object, padj <= 0.2) #get rid of nonsignificant sets
#   
#   # Extract the uniqueID from the fgsea_var using the pattern described
#   uniqueID <- sub(".*_(.+_.+_.+)", "\\1", fgsea_var) #gets rid of unnecessary info in each fgsea obj name; ChatGPT helped write this sub()
#   
#   if (nrow(fgsea_filtered) > 0) {
#     output_data[[fgsea_var]] <- process_fgsea_results(fgsea_filtered, uniqueID) #if there are significant results after filtering, process with function above
#   }
# }
# 
# result_df <- do.call(rbind, output_data)
# genelevelstats <- new.env() #combine results and create a new env to store them in
# 
# for (fgsea_var in all_fgsea_cog) {
#   uniqueID <- sub(".*_(.+_.+_.+)", "\\1", fgsea_var)
#   result_title <- paste("genelevel_", uniqueID, sep = "")
#   genelevelstats[[result_title]] <- result_df[result_df$uniqueID == uniqueID, ]
# } #title and store each result df in genelevelstats
# 
# for (result_title in ls(genelevelstats)) {
#   new_title <- gsub("__", "_", result_title)  
#   new_title <- gsub("_ctamb", "_bactamb", new_title)  
#   new_title <- gsub("_odamb", "_nodamb", new_title)  #fixes some naming oddities resulting from applying the same string manips to strings of diff lengths
#   
#   if (new_title != result_title) {
#     assign(new_title, genelevelstats[[result_title]], envir = genelevelstats)
#     rm(list = result_title, envir = genelevelstats)  #rename and remove original object if necessary
#   }
# }
# 
# #deprecated code for gene-level tables; I misremembered the plan for this and want to keep the code for later adaptation just in case
# 
# groups <- list(
#   group1 = 1:3,
#   group2 = 4:8,
#   group3 = 9:11,
#   group4 = 12:13
# ) #define col ranges
# completefit <- as_tibble(completefit) #convert to tibble for easier manipulation
# grouped_data <- list() #store results
# 
# for (group_name in names(groups)) {
#   rows_to_mean <- groups[[group_name]]
#   grouped_data[[group_name]] <- completefit[rows_to_mean, ] %>%
#     summarise(across(everything(), mean))
# } #mean fitness for each treatment/compartment group
# mean_completefit <- do.call(bind_rows, grouped_data) #mean df
# mean_completefit <- as.data.frame(mean_completefit) #convert back to df
# row.names(mean_completefit) <- c("Nod +N", "Nod -N", "Bact +N", "Bact -N")
# 
# #Make contingency tables for each gene
# 
# genelevel_tables <- new.env() #new env to prevent global env clutter
# 
# for (col_name in colnames(mean_completefit)) {
#   gene_data <- mean_completefit[[col_name]]
#   contingency_table <- matrix(gene_data, nrow = 2, byrow = TRUE,
#                               dimnames = list(c("Nod", "Bact"), c("+N", "-N"))) #build 2x2 tables of fitness values for each gene across the four categories
#   
#   table_name <- paste0(col_name, "_conting")
#   assign(table_name, contingency_table, envir = genelevel_tables)
# } 
# 
# table_names <- ls(envir = genelevel_tables) #store output in list for later use
# 
# #chi sq tests and fdr adjustment
# 
# chi_squared_results <- list()
# for (table_name in table_names) {
#   contingency_table <- get(table_name, envir = genelevel_tables) #retrieve the table object from the indexed name in the input list
#     chi_squared_result <- chisq.test(contingency_table)
#     chi_squared_results[[table_name]] <- chi_squared_result #perform test and store result
# }
# 
# p_values_genelevel <- sapply(chi_squared_results, function(result) result$p.value)
# adjusted_p_values_genelevel <- p.adjust(p_values_genelevel, method = "fdr") #retrieve pvals and perform fdr adjustment
# 
# significant_tables <- table_names[adjusted_p_values_genelevel <= 0.2] #filter for significant results
# significant_tables
#
# #whole-genome fgsea tests
# 
# pathways_complete <- gmtPathways("COGsets_omnibus.gmt")
# 
# fgsea_nodN_complete <- fgsea(pathways_complete, nodN_ranks, minSize = 1, maxSize = 1200)
# fgsea_nodamb_complete <- fgsea(pathways_complete, nodamb_ranks, minSize = 1, maxSize = 1200)
# fgsea_bactN_complete <- fgsea(pathways_complete, bactN_ranks, minSize = 1, maxSize = 1200)
# fgsea_bactamb_complete <- fgsea(pathways_complete, bactamb_ranks, minSize = 1, maxSize = 1200)
#
#notably, no significant results when looking at whole genome without partitioning

# #gene-level type iii anova analysis
# 
# 
# ANOVAcomplete <- COGcomplete
# 
# ANOVAcomplete <- ANOVAcomplete[, -c(32:36)] #remove t0
# 
# ANOVAfitness <- ANOVAcomplete[, c(1, 19:31)]
# 
# anovastrata <- potlabels[-c(14:18)]
# 
# rownames(ANOVAfitness) <- ANOVAfitness$locus_tag
# 
# ANOVAfitness <- t(ANOVAfitness[, -c(1)])
# 
# ANOVAfitness <- data.frame(Ntreatment = c(rep("fertilized",3), rep("ambient",5),rep("fertilized", 3), rep("ambient", 2)), compartment = c(rep("nodule",8), rep("bacteroid",5)), strata = anovastrata, ANOVAfitness)
# 
# 
# anovafit_results <- new.env()
# 
# for (i in 4:ncol(ANOVAfitness)) { #start here to avoid metadata columns
#   col_name <- colnames(ANOVAfitness)[i]
#   
#   formula <- as.formula(paste(col_name, "~ Ntreatment/compartment")) #anova formula
# 
#   anova_result <- Anova(lm(formula, data = ANOVAfitness), type = 'III') #runs anova
#   
#   assign(col_name, anova_result, envir = anovafit_results) #stores in results env
# }
# 
# 
# anovafit_significant <- new.env() 
# 
# for (obj_name in ls(anovafit_results)) {
#   result <- anovafit_results[[obj_name]] #goes through and picks out significant results
#   
#   if (any(result$"Pr(>F)"[1:3] < 0.05)) {
#     assign(obj_name, result, envir = anovafit_significant)
#   }
# }
# 
# anovafit_significant_qval <- new.env() #store results for fdr adjustment
# 
# all_p_values <- numeric()
# all_q_values <- numeric() #more storage
# 
# for (obj_name in ls(anovafit_significant)) {
#   result <- anovafit_significant[[obj_name]]
#   
#   p_values <- result$"Pr(>F)"[1:3]
#   
#   all_p_values <- c(all_p_values, p_values) #gather all the pvals from each listed results object
# }
# 
# all_q_values <- p.adjust(all_p_values, method = "fdr") #adjusts all at once
# split_q_values <- split(all_q_values, rep(seq_along(anovafit_significant), each = 3)) #each input df contributed 3 pvals, so qvals can be doled out in groups of 3
# 
# for (obj_name in ls(anovafit_significant)) {
#   result <- anovafit_significant[[obj_name]]
#   
#   q_values <- split_q_values[[obj_name]]
#   result$qval <- c(q_values, NA) #assigns results and adds an NA for the empty last cell
#   
#   assign(obj_name, result, envir = anovafit_significant_qval) #store results
# }
# 
# # Check the first few objects in anovafit_significant_qval
# head(ls(anovafit_significant_qval)) #NOTE: I never solved the issue of the qval results storing as NAs, and we decided not to use this, so it is interred here



```

---
title: PCoA_relativeabundance_alphadiv_RAC.R
author: User
date: '2023-04-21'

---